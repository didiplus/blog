import{ab as o,G as l,H as p,E as n,N as e,ac as c,S as s,ad as a,W as u}from"./framework-894cff3a.js";const r={},d=a('<h1 id="云原生第4课-kubernetes-集群管理" tabindex="-1"><a class="header-anchor" href="#云原生第4课-kubernetes-集群管理" aria-hidden="true">#</a> 云原生第4课：Kubernetes 集群管理</h1><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>本篇文章来自《华为云云原生王者之路训练营》黄金系列课程第4课，由华为云Kubernetes容器平台技术专家Alan主讲，详细介绍Kubernetes集群和Kubernetes节点的生命周期管理。</p></div><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2>',3),k=a('<figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227113748.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上节课的这张架构图，比较直观地展示了组件如何部署在Master或者Node节点。</p><p>其中Master节点中主要承载了：kubernetes的REST API入口、KV数据库、k8s资源的控制器、负责绑定工作负载到Node的调度器；而Node节点则部署了K8S Agent：kubelet/kubeproxy、容器运行时（CRI）、相关容器存储和网络插件（CNI/CSI）</p><h2 id="kubernetes集群生命周期管理介绍" tabindex="-1"><a class="header-anchor" href="#kubernetes集群生命周期管理介绍" aria-hidden="true">#</a> Kubernetes集群生命周期管理介绍</h2><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227113820.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从部署形态观察Kubernetes集群，可以总结大致有几种部署分类：</p><ol><li><p>自建模式：在拥抱最大的自由度的同时，也必须面临一些庞杂的事务，例如</p><ul><li>计算/存储/网络资源的规划与管理需要对接云基础设施</li><li>Kubernetes的service/ingress需要对接负载均衡服务, storageClass需要对接后端存储</li><li>Master节点以及组件的参数配置、资源扩容、版本升级以及运维。</li><li>Node节点需要基于业务变化进行动态的资源预置、组件部署。</li></ul></li><li><p>托管模式：</p><ul><li>相对于自建模式，</li><li>把非业务相关的平台对接、Kubernetes控制平面等托管给容器平台，</li><li>用户主要聚焦于业务部分，以及承载业务的节点资源的管理。</li></ul></li><li><p>Serverless模式：</p><ul><li>更近一步，把资源的问题全交给容器平台。</li><li>用户仅关注于自身业务 当前也存在自建与托管之间的其他部署形态，比如Kubernetes控制平面用户可以完全控制及修改，但其本质更接近于自建模式。</li></ul></li></ol><ul><li>因为云容器平台由于用户的介入极难保证Kubernetes集群的生命周期及功能可控，最终用户承担较大的风险。</li><li>同时Kubernetes作为开源发布，框架本身就支持各种非侵入式插件，例如自定义调度器、自定义CRD及Controller等等，控制平面非托管的收益并没有想象中高。</li></ul><h2 id="kubernetes集群常见部署方式" tabindex="-1"><a class="header-anchor" href="#kubernetes集群常见部署方式" aria-hidden="true">#</a> Kubernetes集群常见部署方式</h2><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227114113.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),b={class:"hint-container info"},h=n("p",{class:"hint-container-title"},"相关信息",-1),v={href:"https://kubernetes.io/zh/docs/setup/production-environment/tools/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://kubernetes.io/zh/docs/setup/production-environment/turnkey-solutions/",target:"_blank",rel:"noopener noreferrer"},q=a('<p>部署形态主要基于分工与需求考虑，而部署方式就理想照进现实，需要脚踏实地的投入！一般Kubernetes开发者，会采用minikube方式部署一个本地的Kubernetes集群，基本能满足个人调试需求； 更进一步，如果对Kubernetes集群有一定的部署要求，则一般通过第三方工具托管集群的生命周期管理。Kubernetes官方就推荐了3种工具，与详细的使用引导，社区也有大量的部署分享。</p><p>但即使不以生产可用为标准，此类工具的使用仍然需要使用者：具有一定的容器基础知识，需要一定的动手能力和问题解决能力。例如多实例容灾、自签证书、对接软件仓库，在国内环境中部署，需要考虑外网拉包的问题。从个人看，对初学者并不是部署首选，会极大增大学习成本和门槛。从企业看，作为生产环则需要权衡长期使用的，所以，在Kubernetes的生产部署的文档中，明确指出了优先考虑Turkey云解决方案，即使用认证的云容器平台托管。这也是大部分企业使用的形态。</p><p>其实可以发现，平台托管虽然牺牲了灵活度，单在Kubernetes作为实际编排标准的前提下其实是一种非常理智与成熟的决策。由于平台屏蔽了跨云的差异，导致业务跨云迁移和容灾的成本极低，最终容器平台基于统一的Kubernetes聚焦于差异化的竞争力，用户则用脚投票。这对Kubernetes社区与生态的发展是极其有利的。</p><h2 id="kubernetes集群-生产集群" tabindex="-1"><a class="header-anchor" href="#kubernetes集群-生产集群" aria-hidden="true">#</a> Kubernetes集群-生产集群</h2><p>回顾Kubernetes中对生产集群诉求的总结：</p><ul><li>高可用的架构设计</li><li>弹性伸缩的能力</li><li>对安全与权限管理的更高要求。</li></ul><p>基于以上评判标准，就可以发现：从生产集群角度评估，选型/部署只是第一步，真正复杂的是Kubernetes及相关插件的长期监控运维、持续的迭代演进、CVE漏洞的快速分析/修复测试/方案推送等等。</p><p>从华为云CCE的实践看，不止一次地碰到过相对棘手的：OS内核缺陷导致的可靠性问题，例如cgroup的kmem泄露，docker的bug导致的稳定性问题。可以发现，生产集群的维护是一个长期的、庞杂的、系统性的任务，如果每一个Kubernetes的使用者都陷入到上述的柴米油盐中，即使Kubernetes作为容器平台事实标准，其光辉也会因此稍显暗淡。</p>',8),g={href:"https://kubernetes.io/docs/setup/production-environment/",target:"_blank",rel:"noopener noreferrer"},_=a(`<h2 id="kuberbetes节点生命周期介绍" tabindex="-1"><a class="header-anchor" href="#kuberbetes节点生命周期介绍" aria-hidden="true">#</a> Kuberbetes节点生命周期介绍</h2><p><strong>Kubernetes节点介绍-Node定义</strong></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token punctuation">{</span>
   <span class="token key atrule">&quot;kind&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;Node&quot;</span><span class="token punctuation">,</span>
   <span class="token key atrule">&quot;apiVersion&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;v1&quot;</span><span class="token punctuation">,</span>
   <span class="token key atrule">&quot;metadata&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
       <span class="token key atrule">&quot;name&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;192.168.0.10&quot;</span><span class="token punctuation">,</span>
       <span class="token key atrule">&quot;labels&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
           <span class="token key atrule">&quot;name&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;my-first-k8s-node&quot;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token key atrule">&quot;spec&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
       <span class="token key atrule">&quot;providerID&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token key atrule">&quot;status&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
       <span class="token key atrule">&quot;nodeInfo&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
           <span class="token key atrule">&quot;machineID&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token key atrule">&quot;capacity&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
           <span class="token key atrule">&quot;cpu&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span>
           <span class="token key atrule">&quot;memory&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;3864020Ki&quot;</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token key atrule">&quot;allocatable&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
           <span class="token key atrule">&quot;cpu&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span>
           <span class="token key atrule">&quot;memory&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;3864020Ki&quot;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一个有所节选的Kubernetes定义的Node资源对象，从结构上可以发现，大致分成了</p><ul><li>元数据，节点名与节点标签</li><li>节点属性</li><li>节点的状态信息</li></ul>`,5);function f(K,y){const i=u("RouterLink"),t=u("ExternalLinkIcon");return l(),p("div",null,[d,n("p",null,[e(i,{to:"/cloud/huawei/CloudNative/03_kubernetes_basics.html"},{default:c(()=>[s("第3课Kubernetes快速入门")]),_:1}),s("中介绍了Kubernetes的总体架构，其中集群系统组件的部署、节点生命周期管理是第4课关注的重点:")]),k,n("div",b,[h,n("p",null,[n("a",v,[s("Kubernetes部署工具"),e(t)])]),n("p",null,[n("a",m,[s("Turnkey 云解决方案"),e(t)])])]),q,n("p",null,[n("a",g,[s("Kubernetes生产环境"),e(t)])]),_])}const N=o(r,[["render",f],["__file","04_kubernetes_cluster_management.html.vue"]]);export{N as default};
