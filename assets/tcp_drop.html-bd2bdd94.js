import{ab as a,G as t,H as o,E as n,S as s,N as r,ad as i,W as c}from"./framework-894cff3a.js";const p={},g=n("h1",{id:"_4-21-用了-tcp-协议-数据一定不会丢吗",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_4-21-用了-tcp-协议-数据一定不会丢吗","aria-hidden":"true"},"#"),s(" 4.21 用了 TCP 协议，数据一定不会丢吗？")],-1),d=n("p",null,"来源：公众号@小白debug",-1),l={href:"https://mp.weixin.qq.com/s/XNJoaVnYT1SxHsdNWeAaUw",target:"_blank",rel:"noopener noreferrer"},m=i(`<p>大家后，我是小林。</p><p>问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？</p><p>这次，就跟大家探讨这个问题。</p><h2 id="数据包的发送流程" tabindex="-1"><a class="header-anchor" href="#数据包的发送流程" aria-hidden="true">#</a> 数据包的发送流程</h2><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/1d0a1d60ca4f720423911cf8f25c4ac3.png" alt="聊天软件三端通信" tabindex="0" loading="lazy"><figcaption>聊天软件三端通信</figcaption></figure><p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP协议</strong>进行通信。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/7e8bae365b8d27560aac1cd28f501156.png" alt="聊天软件两端通信" tabindex="0" loading="lazy"><figcaption>聊天软件两端通信</figcaption></figure><p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立TCP连接。</p><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过n多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/28e4d6b004530fbf75fe346d181baa81.png" alt="网络发包收包全景图" tabindex="0" loading="lazy"><figcaption>网络发包收包全景图</figcaption></figure><blockquote><p>画了那么大一张图，只水了200字做解释，我多少是有些心痛的。</p></blockquote><p>到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p><p>可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p><p>整条链路下来，有不少地方可能会发生丢包。</p><p>但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p><h2 id="建立连接时丢包" tabindex="-1"><a class="header-anchor" href="#建立连接时丢包" aria-hidden="true">#</a> 建立连接时丢包</h2><p>TCP协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/923f5005edb536c0d07b096bbf2ca282.png" alt="TCP三次握手" tabindex="0" loading="lazy"><figcaption>TCP三次握手</figcaption></figure><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/02a78bb83fe167324f26e8c910d7a7a2.png" alt="半连接队列和全连接队列" tabindex="0" loading="lazy"><figcaption>半连接队列和全连接队列</figcaption></figure><p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p>可以通过下面的方式查看是否存在这种丢包行为。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 全连接队列溢出次数</span>
<span class="token comment"># netstat -s | grep overflowed</span>
    <span class="token number">4343</span> <span class="token builtin class-name">times</span> the listen queue of a socket overflowed

<span class="token comment"># 半连接队列溢出次数</span>
<span class="token comment"># netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;</span>
    <span class="token number">109</span> <span class="token builtin class-name">times</span> the listen queue of a socket overflowed 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从现象来看就是连接建立失败。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/591d630098b4fc5316a5005f1e94b844.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="流量控制丢包" tabindex="-1"><a class="header-anchor" href="#流量控制丢包" aria-hidden="true">#</a> 流量控制丢包</h2><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p><p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/6f2821018be08a2f27561155e8085de4.png" alt="qdisc丢包" tabindex="0" loading="lazy"><figcaption>qdisc丢包</figcaption></figure><p>可以通过下面的<code>ifconfig</code>命令，查看TX下的dropped字段，当它大于0时，则<strong>有可能</strong>是发生了流控丢包。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ifconfig eth0</span>
eth0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">416</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">&gt;</span>  mtu <span class="token number">1500</span>
        inet <span class="token number">172.21</span>.66.69  netmask <span class="token number">255.255</span>.240.0  broadcast <span class="token number">172.21</span>.79.255
        inet6 fe80::216:3eff:fe25:269f  prefixlen <span class="token number">64</span>  scopeid 0x2<span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>link<span class="token operator">&gt;</span>
        ether 00:16:3e:25:26:9f  txqueuelen <span class="token number">1000</span>  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>
        RX packets <span class="token number">6962682</span>  bytes <span class="token number">1119047079</span> <span class="token punctuation">(</span><span class="token number">1.0</span> GiB<span class="token punctuation">)</span>
        RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>
        TX packets <span class="token number">9688919</span>  bytes <span class="token number">2072511384</span> <span class="token punctuation">(</span><span class="token number">1.9</span> GiB<span class="token punctuation">)</span>
        TX errors <span class="token number">0</span>  dropped <span class="token number">0</span> overruns <span class="token number">0</span>  carrier <span class="token number">0</span>  collisions <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将eth0网卡的流控队列长度从1000提升为1500.</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ifconfig eth0 txqueuelen 1500</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="网卡丢包" tabindex="-1"><a class="header-anchor" href="#网卡丢包" aria-hidden="true">#</a> 网卡丢包</h2><p>网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p><h3 id="ringbuffer过小导致丢包" tabindex="-1"><a class="header-anchor" href="#ringbuffer过小导致丢包" aria-hidden="true">#</a> RingBuffer过小导致丢包</h3><p>上面提到，在接收数据时，会将数据暂存到<code>RingBuffer</code>接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/8f3ed2d6c4e2e154849f1e661528fe89.png" alt="RingBuffer满了导致丢包" tabindex="0" loading="lazy"><figcaption>RingBuffer满了导致丢包</figcaption></figure><p>我们可以通过下面的命令去查看是否发生过这样的事情。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ifconfig</span>
eth0:  RX errors <span class="token number">0</span>  dropped <span class="token number">0</span>  overruns <span class="token number">0</span>  frame <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看上面的<code>overruns</code>指标，它记录了由于<code>RingBuffer</code>长度不足导致的溢出次数。</p><p>当然，用<code>ethtool</code>命令也能查看。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ethtool -S eth0|grep rx_queue_0_drops</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但这里需要注意的是，因为一个网卡里是可以有<strong>多个RingBuffer</strong>的，所以上面的<code>rx_queue_0_drops</code>里的0代表的是<strong>第0个RingBuffer</strong>的丢包数，对于多队列的网卡，这个0还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p><p>当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#ethtool -g eth0</span>
Ring parameters <span class="token keyword">for</span> eth0:
Pre-set maximums:
RX:        <span class="token number">4096</span>
RX Mini:    <span class="token number">0</span>
RX Jumbo:    <span class="token number">0</span>
TX:        <span class="token number">4096</span>
Current hardware settings:
RX:        <span class="token number">1024</span>
RX Mini:    <span class="token number">0</span>
RX Jumbo:    <span class="token number">0</span>
TX:        <span class="token number">1024</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的输出内容，含义是<strong>RingBuffer最大支持4096的长度，但现在实际只用了1024。</strong></p><p>想要修改这个长度可以执行<code>ethtool -G eth1 rx 4096 tx 4096</code>将发送和接收RingBuffer的长度都改为4096。</p><p><strong>RingBuffer</strong>增大之后，可以减少因为容量小而导致的丢包情况。</p><h3 id="网卡性能不足" tabindex="-1"><a class="header-anchor" href="#网卡性能不足" aria-hidden="true">#</a> 网卡性能不足</h3><p>网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p><p>我们可以通过<code>ethtool</code>加网卡名，获得当前网卡支持的最大速度。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># ethtool eth0</span>
Settings <span class="token keyword">for</span> eth0:
    Speed: 10000Mb/s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，我这边用的网卡能支持的最大传输速度<strong>speed=1000Mb/s</strong>。</p><p>也就是俗称的千兆网卡，但注意这里的单位是<strong>Mb</strong>，这里的<strong>b是指bit，而不是Byte。1Byte=8bit</strong>。所以10000Mb/s还要除以8，也就是理论上网卡最大传输速度是<code>1000/8 = 125MB/s</code>。</p><p>我们可以通过<code>sar命令</code>从网络接口层面来分析数据包的收发情况。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># sar -n DEV 1</span>
Linux <span class="token number">3.10</span>.0-1127.19.1.el7.x86_64      <span class="token number">2022</span>年07月27日     _x86_64_    <span class="token punctuation">(</span><span class="token number">1</span> CPU<span class="token punctuation">)</span>

08时35分39秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s    rxcmp/s   txcmp/s  rxmcst/s
08时35分40秒      eth0      <span class="token number">6.06</span>      <span class="token number">4.04</span>      <span class="token number">0.35</span>    <span class="token number">121682.33</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>     <span class="token number">0.00</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <strong>txkB/s是指当前每秒发送的字节（byte）总数，rxkB/s是指每秒接收的字节（byte）总数</strong>。</p><p>当两者加起来的值约等于<code>12~13w字节</code>的时候，也就对应大概<code>125MB/s</code>的传输速度。此时达到网卡性能极限，就会开始丢包。</p><p>遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p><h2 id="接收缓冲区丢包" tabindex="-1"><a class="header-anchor" href="#接收缓冲区丢包" aria-hidden="true">#</a> 接收缓冲区丢包</h2><p>我们一般使用<code>TCP socket</code>进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p><p>当我们想要发一个数据包，会在代码里执行<code>send(msg)</code>，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/9cd22437777205662048c73cc5855add.png" alt="tcp_sendmsg逻辑" tabindex="0" loading="lazy"><figcaption>tcp_sendmsg逻辑</figcaption></figure><p>而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p><p>这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看接收缓冲区</span>
<span class="token comment"># sysctl net.ipv4.tcp_rmem</span>
net.ipv4.tcp_rmem <span class="token operator">=</span> <span class="token number">4096</span>    <span class="token number">87380</span>   <span class="token number">6291456</span>

<span class="token comment"># 查看发送缓冲区</span>
<span class="token comment"># sysctl net.ipv4.tcp_wmem</span>
net.ipv4.tcp_wmem <span class="token operator">=</span> <span class="token number">4096</span>    <span class="token number">16384</span>   <span class="token number">4194304</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在min和max之间动态调整。</strong></p><p><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p><p>对于<strong>发送缓冲区</strong>，执行send的时候，如果是<strong>阻塞</strong>调用，那就会等，等到缓冲区有空位可以发数据。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/7312e536393463dcf0d57aeb07f28ed5.gif" alt="send阻塞" tabindex="0" loading="lazy"><figcaption>send阻塞</figcaption></figure><p>如果是<strong>非阻塞</strong>调用，就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是 <code>Try again</code>。让应用程序下次再重试。这种情况下一般不会发生丢包。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/f378a299ca60c490ee5437e1143916c8.gif" alt="send非阻塞" tabindex="0" loading="lazy"><figcaption>send非阻塞</figcaption></figure><p>当接受缓冲区满了，事情就不一样了，它的TCP接收窗口会变为0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的<code>win=0</code>，告诉发送端，&quot;球球了，顶不住了，别发了&quot;。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/2df66c2e1d9f1245813e8d1de7482e0c.png" alt="recv_buffer丢包" tabindex="0" loading="lazy"><figcaption>recv_buffer丢包</figcaption></figure><p>我们可以通过下面的命令里的<code>TCPRcvQDrop</code>查看到有没有发生过这种丢包现象。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> /proc/net/netstat
TcpExt: SyncookiesSent TCPRcvQDrop SyncookiesFailed
TcpExt: <span class="token number">0</span>              <span class="token number">157</span>              <span class="token number">60116</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是说个伤心的事情，我们一般也看不到这个<code>TCPRcvQDrop</code>，因为这个是<code>5.9版本</code>里引入的打点，而我们的服务器用的一般是<code>2.x~3.x</code>左右版本。你可以通过下面的命令查看下你用的是什么版本的linux内核。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># cat /proc/version</span>
Linux version <span class="token number">3.10</span>.0-1127.19.1.el7.x86_64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="两端之间的网络丢包" tabindex="-1"><a class="header-anchor" href="#两端之间的网络丢包" aria-hidden="true">#</a> 两端之间的网络丢包</h2><p>前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p>这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p><h3 id="ping命令查看丢包" tabindex="-1"><a class="header-anchor" href="#ping命令查看丢包" aria-hidden="true">#</a> <strong>ping命令查看丢包</strong></h3><p>比如我们知道目的地的域名是 <code>baidu.com</code>。想知道你的机器到baidu服务器之间，有没有产生丢包行为。可以使用ping命令。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/56bdca9995c0c2a343b2b73b67933b78.png" alt="ping查看丢包" tabindex="0" loading="lazy"><figcaption>ping查看丢包</figcaption></figure><p>倒数第二行里有个<code>100% packet loss</code>，意思是丢包率100%。</p><p>但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p><p><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p><p>有。</p><h3 id="mtr命令" tabindex="-1"><a class="header-anchor" href="#mtr命令" aria-hidden="true">#</a> <strong>mtr命令</strong></h3><p>mtr命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p>像下面这样执行命令。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/4a2d8dbfb648bcced864fb653af9f036.png" alt="mtr_icmp" tabindex="0" loading="lazy"><figcaption>mtr_icmp</figcaption></figure><p>其中 -r 是指report，以报告的形式打印结果。</p><p>可以看到<code>Host</code>那一列，出现的都是链路中间每一跳的机器，<code>Loss</code>的那一列就是指这一跳对应的丢包率。</p><p>需要注意的是，中间有一些是host是<code>???</code>，那个是因为<strong>mtr默认用的是ICMP包</strong>，有些节点限制了<strong>ICMP包</strong>，导致不能正常展示。</p><p>我们可以在mtr命令里加个<code>-u</code>，也就是使用<strong>udp包</strong>，就能看到部分???对应的IP。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/0650adc524ab7d82028dc83cfc9961e1.png" alt="mtr-udp" tabindex="0" loading="lazy"><figcaption>mtr-udp</figcaption></figure><p>把<strong>ICMP包和UDP包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p><p>还有个小细节，<code>Loss</code>那一列，我们在icmp的场景下，关注<strong>最后一行</strong>，如果是0%，那不管前面loss是100%还是80%都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p><p>但如果<strong>最后一行是20%，再往前几行都是20%左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/7142a4e285024dc6aadea4255984c485.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="发生丢包了怎么办" tabindex="-1"><a class="header-anchor" href="#发生丢包了怎么办" aria-hidden="true">#</a> 发生丢包了怎么办</h2><p>说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p><p>但问题来了，发生丢包了怎么办？</p><p>这个好办，用<strong>TCP协议</strong>去做传输。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/b2225e071fec7cfb240aa295ed4037bf.png" alt="TCP是什么" tabindex="0" loading="lazy"><figcaption>TCP是什么</figcaption></figure><p>建立了TCP连接的两端，发送端在发出数据后会等待接收端回复<code>ack包</code>，<code>ack包</code>的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用TCP不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/c1460d52efe7c5e4d80c2f7160d5b126.png" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这时候问题又来了。</p><p>假设<strong>某绿皮聊天软件用的就是TCP协议。</strong></p><p>在聊天的时候， 发生丢包了，丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p><p>于是乎，问题就变成了，<strong>用了 TCP 协议，就一定不会丢包吗？</strong></p><h2 id="用了tcp协议就一定不会丢包吗" tabindex="-1"><a class="header-anchor" href="#用了tcp协议就一定不会丢包吗" aria-hidden="true">#</a> 用了TCP协议就一定不会丢包吗</h2><p>我们知道TCP位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的HTTP或者各类RPC协议。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/c6794dd51c8780f12e4022fc964ebb0a.png" alt="四层网络协议" tabindex="0" loading="lazy"><figcaption>四层网络协议</figcaption></figure><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层TCP协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层TCP接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里TCP的任务就结束了。</p><p>TCP任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><figure><img src="https://img-blog.csdnimg.cn/img_convert/9286ab84bcaa74576bc11c8e9322fee9.png" alt="使用TCP协议却发生丢包" tabindex="0" loading="lazy"><figcaption>使用TCP协议却发生丢包</figcaption></figure><p><strong>虽然概率很小，但它就是发生了</strong>。</p><p>合情合理，逻辑自洽。</p><h2 id="这类丢包问题怎么解决" tabindex="-1"><a class="header-anchor" href="#这类丢包问题怎么解决" aria-hidden="true">#</a> 这类丢包问题怎么解决？</h2><p>故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p><p><strong>其实前面说的都对，没有一句是假话</strong>。</p><p>但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p><p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p><strong>现在我们重新将服务器加回来。</strong></p><figure><img src="https://img-blog.csdnimg.cn/img_convert/d53659df39d64db4780d2816bd8314d1.png" alt="聊天软件三端通信" tabindex="0" loading="lazy"><figcaption>聊天软件三端通信</figcaption></figure><p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>可以看出，<strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul><p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说丢包不可避免。</li><li>平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。</li><li>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。</li><li>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</li></ul><hr><p><em><strong>哈喽，我是小林，就爱图解计算机基础，如果觉得文章对你有帮助，欢迎微信搜索「小林coding」</strong></em></p><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/其他/公众号介绍.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>`,152);function u(b,f){const e=c("ExternalLinkIcon");return t(),o("div",null,[g,n("blockquote",null,[d,n("p",null,[s("原文地址："),n("a",l,[s("用了 TCP 协议，数据一定不会丢吗？"),r(e)])])]),m])}const h=a(p,[["render",u],["__file","tcp_drop.html.vue"]]);export{h as default};
