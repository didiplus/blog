import{ab as u,G as p,H as d,N as s,E as e,S as n,ac as t,ad as m,W as a}from"./framework-894cff3a.js";const k={},b=e("h1",{id:"_2-3、公布应用程序",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-3、公布应用程序","aria-hidden":"true"},"#"),n(" 2.3、公布应用程序")],-1),_={href:"https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/",target:"_blank",rel:"noopener noreferrer"},h=e("h2",{id:"目标",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目标","aria-hidden":"true"},"#"),n(" 目标")],-1),v=e("ul",null,[e("li",null,"了解 Kubernetes 的 Service（服务）"),e("li",null,"了解 Labels（标签）和 LabelSelector（标签选择器）与 Service（服务）的关系"),e("li",null,"在 kubernetes 集群中，通过 Service（服务）向外公布应用程序")],-1),g=e("h2",{id:"kubernetes-service-服务-概述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kubernetes-service-服务-概述","aria-hidden":"true"},"#"),n(" Kubernetes Service（服务）概述")],-1),y={href:"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,"举个例子，假设有一个图像处理后端程序，具有 3 个运行时副本。这 3 个副本是可以替换的（无状态应用），即使 Pod（容器组）消失并被重新创建，或者副本数由 3 增加到 5，前端系统也无需关注后端副本的变化。由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。",-1),S=e("strong",null,"Service（服务）",-1),f=e("strong",null,"Pod（容器组）",-1),L=e("strong",null,"LabelSelector(标签选择器)",-1),A=m('<p>在创建Service的时候，通过设置配置文件中的 spec.type 字段的值，可以以不同方式向外部暴露应用程序：</p><ul><li><p><strong>ClusterIP</strong>（默认）</p><p>在群集中的内部IP上公布服务，这种方式的 Service（服务）只在集群内部可以访问到</p></li><li><p><strong>NodePort</strong></p><p>使用 NAT 在集群中每个的同一端口上公布服务。这种方式下，可以通过访问集群中任意节点+端口号的方式访问服务 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>。此时 ClusterIP 的访问方式仍然可用。</p></li><li><p><strong>LoadBalancer</strong></p><p>在云环境中（需要云供应商可以支持）创建一个集群外部的负载均衡器，并为使用该负载均衡器的 IP 地址作为服务的访问地址。此时 ClusterIP 和 NodePort 的访问方式仍然可用。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>Service是一个抽象层，它通过 LabelSelector 选择了一组 Pod（容器组），把这些 Pod 的指定端口公布到到集群外部，并支持负载均衡和服务发现。</p><ul><li>公布 Pod 的端口以使其可访问</li><li>在多个 Pod 间实现负载均衡</li><li>使用 Label 和 LabelSelector</li></ul></div><h2 id="服务和标签" tabindex="-1"><a class="header-anchor" href="#服务和标签" aria-hidden="true">#</a> 服务和标签</h2><p>下图中有两个服务Service A(黄色虚线)和Service B(蓝色虚线) Service A 将请求转发到 IP 为 10.10.10.1 的Pod上， Service B 将请求转发到 IP 为 10.10.10.2、10.10.10.3、10.10.10.4 的Pod上。</p><figure><img src="https://kuboard.cn/assets/img/module_04_services.11cdc7bc.svg" alt="Kubernetes教程：服务和标签" tabindex="0" loading="lazy"><figcaption>Kubernetes教程：服务和标签</figcaption></figure>',6),I={href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels",target:"_blank",rel:"noopener noreferrer"},K=e("ul",null,[e("li",null,"将 Kubernetes 对象（Node、Deployment、Pod、Service等）指派用于开发环境、测试环境或生产环境"),e("li",null,"嵌入版本标签，使用标签区别不同应用软件版本"),e("li",null,"使用标签对 Kubernetes 对象进行分类")],-1),B=e("p",null,"下图体现了 Labels（标签）和 LabelSelector（标签选择器）之间的关联关系",-1),N=e("li",null,"通过 Deployment B 创建的 Pod 包含标签为 app=B",-1),D=e("li",null,"Service B 通过标签选择器 app=B 选择可以路由的 Pod",-1),w=e("figure",null,[e("img",{src:"https://kuboard.cn/assets/img/module_04_labels.3255e3d0.svg",alt:"Kubernetes教程：服务和标签",tabindex:"0",loading:"lazy"}),e("figcaption",null,"Kubernetes教程：服务和标签")],-1),C=e("p",null,"Labels（标签）可以在创建 Kubernetes 对象时附加上去，也可以在创建之后再附加上去。任何时候都可以修改一个 Kubernetes 对象的 Labels（标签）",-1),T=e("h2",{id:"实战-为您的-nginx-deployment-创建一个-service",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#实战-为您的-nginx-deployment-创建一个-service","aria-hidden":"true"},"#"),n(" 实战：为您的 nginx Deployment 创建一个 Service")],-1),E=e("p",null,"创建nginx的Deployment中定义了Labels，如下：",-1),V=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token key atrule"},"metadata"),e("span",{class:"token punctuation"},":"),n("	"),e("span",{class:"token comment"},"#译名为元数据，即Deployment的一些基本属性和信息"),n(`
  `),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" nginx"),e("span",{class:"token punctuation"},"-"),n("deployment	"),e("span",{class:"token comment"},"#Deployment的名称"),n(`
  `),e("span",{class:"token key atrule"},"labels"),e("span",{class:"token punctuation"},":"),n("	"),e("span",{class:"token comment"},"#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组"),n(`
    `),e("span",{class:"token key atrule"},"app"),e("span",{class:"token punctuation"},":"),n(" nginx	"),e("span",{class:"token comment"},"#为该Deployment设置key为app，value为nginx的标签"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),z=e("p",null,[e("strong",null,"创建文件 nginx-service.yaml")],-1),R=e("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[e("pre",{class:"language-bash"},[e("code",null,[e("span",{class:"token function"},"vim"),n(` nginx-service.yaml
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),U=e("p",null,[e("strong",null,"文件内容如下：")],-1),j=e("div",{class:"language-yaml line-numbers-mode","data-ext":"yml"},[e("pre",{class:"language-yaml"},[e("code",null,[e("span",{class:"token key atrule"},"apiVersion"),e("span",{class:"token punctuation"},":"),n(` v1
`),e("span",{class:"token key atrule"},"kind"),e("span",{class:"token punctuation"},":"),n(` Service
`),e("span",{class:"token key atrule"},"metadata"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" nginx"),e("span",{class:"token punctuation"},"-"),n("service	"),e("span",{class:"token comment"},"#Service 的名称"),n(`
  `),e("span",{class:"token key atrule"},"labels"),e("span",{class:"token punctuation"},":"),n("     	"),e("span",{class:"token comment"},"#Service 自己的标签"),n(`
    `),e("span",{class:"token key atrule"},"app"),e("span",{class:"token punctuation"},":"),n(" nginx	"),e("span",{class:"token comment"},"#为该 Service 设置 key 为 app，value 为 nginx 的标签"),n(`
`),e("span",{class:"token key atrule"},"spec"),e("span",{class:"token punctuation"},":"),n("	    "),e("span",{class:"token comment"},"#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问"),n(`
  `),e("span",{class:"token key atrule"},"selector"),e("span",{class:"token punctuation"},":"),n("	    "),e("span",{class:"token comment"},"#标签选择器"),n(`
    `),e("span",{class:"token key atrule"},"app"),e("span",{class:"token punctuation"},":"),n(" nginx	"),e("span",{class:"token comment"},"#选择包含标签 app:nginx 的 Pod"),n(`
  `),e("span",{class:"token key atrule"},"ports"),e("span",{class:"token punctuation"},":"),n(`
  `),e("span",{class:"token punctuation"},"-"),n(),e("span",{class:"token key atrule"},"name"),e("span",{class:"token punctuation"},":"),n(" nginx"),e("span",{class:"token punctuation"},"-"),n("port	"),e("span",{class:"token comment"},"#端口的名字"),n(`
    `),e("span",{class:"token key atrule"},"protocol"),e("span",{class:"token punctuation"},":"),n(" TCP	    "),e("span",{class:"token comment"},"#协议类型 TCP/UDP"),n(`
    `),e("span",{class:"token key atrule"},"port"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"80"),n("	        "),e("span",{class:"token comment"},"#集群内的其他容器组可通过 80 端口访问 Service"),n(`
    `),e("span",{class:"token key atrule"},"nodePort"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"32600"),n("   "),e("span",{class:"token comment"},"#通过任意节点的 32600 端口访问 Service"),n(`
    `),e("span",{class:"token key atrule"},"targetPort"),e("span",{class:"token punctuation"},":"),n(),e("span",{class:"token number"},"80"),n("	"),e("span",{class:"token comment"},"#将请求转发到匹配 Pod 的 80 端口"),n(`
  `),e("span",{class:"token key atrule"},"type"),e("span",{class:"token punctuation"},":"),n(" NodePort	"),e("span",{class:"token comment"},"#Serive的类型，ClusterIP/NodePort/LoaderBalancer"),n(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),q=e("p",null,[e("strong",null,"执行命令")],-1),G=e("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[e("pre",{class:"language-bash"},[e("code",null,[n("kubectl apply "),e("span",{class:"token parameter variable"},"-f"),n(` nginx-service.yaml
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),H=e("p",null,[e("strong",null,"检查执行结果")],-1),W=e("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[e("pre",{class:"language-bash"},[e("code",null,[n("kubectl get services "),e("span",{class:"token parameter variable"},"-o"),n(` wide
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),Y=e("p",null,"可查看到名称为 nginx-service 的服务。",-1),F=e("p",null,[e("strong",null,"访问服务")],-1),J=e("div",{class:"language-bash line-numbers-mode","data-ext":"sh"},[e("pre",{class:"language-bash"},[e("code",null,[e("span",{class:"token function"},"curl"),n(),e("span",{class:"token operator"},"<"),n("任意节点的 IP"),e("span",{class:"token operator"},">"),n(`:32600
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),M=e("blockquote",null,[e("p",null,"如果您的集群在云上，您可能通过云服务商的安全组开放 32600 端口的访问")],-1),O=e("p",null,null,-1),Q=e("p",null,"~~到目前为止，我们已经成功部署好项目，并能够对其进行访问，",-1),X=e("p",null,"~~接下来是对于多实例部署和滚动更新的相关介绍与实践",-1);function Z($,ee){const c=a("AdSenseTitle"),l=a("ExternalLinkIcon"),o=a("font"),i=a("Tabs"),r=a("RouterLink");return p(),d("div",null,[b,s(c),e("p",null,[n("本文翻译自 Kubernetes "),e("a",_,[n("Using a Service to Expose Your App"),s(l)]),n(" ，并有所改写")]),h,v,g,e("p",null,[n("事实上，Pod（容器组）有自己的 "),e("a",y,[n("生命周期"),s(l)]),n("。当 worker node（节点）故障时，节点上运行的 Pod（容器组）也会消失。然后，"),e("a",P,[n("Deployment"),s(l)]),n(" 可以通过创建新的 Pod（容器组）来动态地将群集调整回原来的状态，以使应用程序保持运行。")]),x,e("p",null,[n("Kubernetes 中的 "),S,n(" 提供了这样的一个抽象层，它选择具备某些特征的 Pod（容器组）并为它们定义一个访问方式。Service（服务）使 Pod（容器组）之间的相互依赖解耦"),s(o,{color:"#999999"},{default:t(()=>[n("（原本从一个 Pod 中访问另外一个 Pod，需要知道对方的 IP 地址）")]),_:1}),n("。一个 Service（服务）选定哪些 "),f,n(" 通常由 "),L,n(" 来决定。")]),A,e("p",null,[n("Service 将外部请求路由到一组 Pod 中，它提供了一个抽象层，使得 Kubernetes 可以在不影响服务调用者的情况下，动态调度容器组"),s(o,{color:"#AAAAAA"},{default:t(()=>[n("（在容器组失效后重新创建容器组，增加或者减少同一个 Deployment 对应容器组的数量等）")]),_:1}),n("。")]),e("p",null,[n("Service使用 "),e("a",I,[n("Labels、LabelSelector(标签和选择器)"),s(l)]),n(" 匹配一组 Pod。Labels（标签）是附加到 Kubernetes 对象的键/值对，其用途有多种：")]),K,B,e("ul",null,[e("li",null,[n("Deployment B 含有 LabelSelector 为 app=B "),s(o,{color:"#AAAAAA"},{default:t(()=>[n("通过此方式声明含有 app=B 标签的 Pod 与之关联")]),_:1})]),N,D]),w,C,T,s(i,{id:"152",data:[{title:"使用kubectl"}],active:0},{tab0:t(({title:ne,value:se,isActive:te})=>[E,V,z,R,U,j,q,G,H,W,Y,F,J,M,O]),_:1}),Q,X,e("p",null,[n("~~let‘s go-> "),s(r,{to:"/cloud/k8s/k8s-basics/scale.html"},{default:t(()=>[n("应用程序的伸缩")]),_:1})])])}const le=u(k,[["render",Z],["__file","expose.html.vue"]]);export{le as default};
