import{ab as t,G as e,H as l,ad as i}from"./framework-894cff3a.js";const a={},d=i(`<h1 id="云原生第2课-云原生技术体系中的基石-容器技术" tabindex="-1"><a class="header-anchor" href="#云原生第2课-云原生技术体系中的基石-容器技术" aria-hidden="true">#</a> 云原生第2课：云原生技术体系中的基石-容器技术</h1><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>本篇文章来自《华为云云原生王者之路训练营》黄金系列课程第2课，由华为云容器技术专家Jarvis Zhou主讲，帮助大家了解容器技术的发展历程；对容器镜像有初步的了解，并能编写简单的Dockerfile；可以完成镜像制作、上传、下载等操作。</p></div><h2 id="容器技术发展简介" tabindex="-1"><a class="header-anchor" href="#容器技术发展简介" aria-hidden="true">#</a> 容器技术发展简介</h2><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h3><p>在之前的开发运维中，应用和环境的交付是分离的，较难在开发环境和生产环境无法保持一致，容易出现各种环境问题:</p><ul><li>对于公司而言，服务器、存储等作为成本之一，希望能追求高效的利用已有的服务资源。在容器之前，可能直接将多应用部署在同一机器上；也可能是采取虚拟机等方式在同一物理服务器上；</li><li>对于直接部署在同一机器上的场景，就需要考虑应用之间的隔离和资源的抢占问题。</li><li>而对于使用虚拟机的场景，虚机虽然提供了很好的隔离性，但是虚拟机本身占用了大量的资源，并且启动时间慢。</li></ul><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>在Linux中，容器技术是一种进程隔离的技术，应用可以运行在一个个相互隔离的容器中，与虚拟机相同的是，可以为这些容器设置计算资源限制，挂载存储，连接网络，而与虚拟机不同的是，这些应用运行时共用着一个Kernel。</p><p>这些技术的基础就是Linux的LXC（Linux Container），通过将Cgoups的资源管理能力和Linux Namepsace的隔离能力组合在一起</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227103431.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="cgroup" tabindex="-1"><a class="header-anchor" href="#cgroup" aria-hidden="true">#</a> Cgroup</h4><p>Cgroup实现容器资源的限制，包括很多子模块，在容器中，我们主要用到cpu子模块和memory子模块，memory是实现内存的隔离，cpu主要限制进程的 cpu 使用率。</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227103505.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><table><thead><tr><th style="text-align:left;">子系统</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">blkio</td><td style="text-align:left;">为块设备设定输入/输出限制，比如物理设备(磁盘固态硬盘，USB 等等)</td></tr><tr><td style="text-align:left;">cpu</td><td style="text-align:left;">使用调度程序提供对CPU的cgroup任务访问</td></tr><tr><td style="text-align:left;">cpuacct</td><td style="text-align:left;">自动生成cgroup中任务所使用的CPU报告</td></tr><tr><td style="text-align:left;">cpuset</td><td style="text-align:left;">为cgroup中的任务分配独立CPU(在多核系统)和内存节点</td></tr><tr><td style="text-align:left;">devices</td><td style="text-align:left;">允许或者拒绝cgroup中的任务访问设备</td></tr><tr><td style="text-align:left;">freezer</td><td style="text-align:left;">挂起或者恢复cgroup中的任务</td></tr><tr><td style="text-align:left;">memory</td><td style="text-align:left;">设定cgroup中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告</td></tr><tr><td style="text-align:left;">net cls</td><td style="text-align:left;">使用等级识别符(classid)标记网络数据包，可允许Linux流量控制程序(tc)识别从具体cgroup中生成的数据包</td></tr></tbody></table><h4 id="namespace" tabindex="-1"><a class="header-anchor" href="#namespace" aria-hidden="true">#</a> Namespace</h4><p>Linux Namespace提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的Namespace中，来实现资源隔离的目的。不同Namespace的程序，可以享有一份独立的系统资源。</p><table><thead><tr><th style="text-align:left;">Namespace</th><th style="text-align:left;">隔离内容</th></tr></thead><tbody><tr><td style="text-align:left;">UTS</td><td style="text-align:left;">主机名与域名</td></tr><tr><td style="text-align:left;">IPC</td><td style="text-align:left;">信号量、消息队列和共享内存</td></tr><tr><td style="text-align:left;">PID</td><td style="text-align:left;">进程编号</td></tr><tr><td style="text-align:left;">Network</td><td style="text-align:left;">网络设备，网络栈，端口等</td></tr><tr><td style="text-align:left;">Mount</td><td style="text-align:left;">挂载点</td></tr><tr><td style="text-align:left;">User</td><td style="text-align:left;">用户和用户组</td></tr></tbody></table><h2 id="docker容器和容器镜像技术介绍" tabindex="-1"><a class="header-anchor" href="#docker容器和容器镜像技术介绍" aria-hidden="true">#</a> Docker容器和容器镜像技术介绍</h2><p>Docker 公司起初是一家名为 dotCloud 的PaaS提供商，是一个用于开发，交付和运行应用程序的开放平台。Docker 能够将应用程序与基础架构分开，从而可以快速交付软件。</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227104227.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>借助 Docker，可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h3 id="docker-vs-vm" tabindex="-1"><a class="header-anchor" href="#docker-vs-vm" aria-hidden="true">#</a> Docker VS VM</h3><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227104302.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>docker启动快速属于秒级别</strong>。虚拟机通常需要几分钟去启动。</li><li><strong>docker需要的资源更少</strong>，docker在操作系统级别进行虚拟化，docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。</li><li><strong>docker更轻量</strong>，docker的架构可以共用一个内核与共享应用程序库，所占内存极小。</li><li><strong>高可用和可恢复性</strong>：docker对业务的高可用支持是通过快速重新部署实现的。</li><li><strong>快速创建、删除</strong>：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</li><li><strong>交付、部署</strong>：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署。</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227104457.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>首先开发者在开发环境机器上开发应用并制作镜像。Docker执行命令，构建镜像并存储在机器上。</li><li>开发者发送上传镜像命令。Docker收到命令后，将本地镜像上传到镜像仓库。</li><li>开发者向生产环境机器发送运行镜像命令。生产环境机器收到命令后，Docker会从镜像仓库拉取镜像到机器上，然后基于镜像运行容器。</li></ul><h3 id="docker常用命令" tabindex="-1"><a class="header-anchor" href="#docker常用命令" aria-hidden="true">#</a> Docker常用命令</h3><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">build</td><td style="text-align:left;">根据 Dockerfile 文件构建镜像</td></tr><tr><td style="text-align:left;">exec</td><td style="text-align:left;">在已运行的容器中执行命令</td></tr><tr><td style="text-align:left;">images</td><td style="text-align:left;">列出本地所有镜像</td></tr><tr><td style="text-align:left;">load</td><td style="text-align:left;">导入镜像压缩包</td></tr><tr><td style="text-align:left;">login</td><td style="text-align:left;">登录第三方仓库</td></tr><tr><td style="text-align:left;">logout</td><td style="text-align:left;">退出第三方仓库</td></tr><tr><td style="text-align:left;">logs</td><td style="text-align:left;">打印容器的控制台输出内容</td></tr><tr><td style="text-align:left;">pause</td><td style="text-align:left;">暂停容器</td></tr><tr><td style="text-align:left;">ps</td><td style="text-align:left;">列出正在运行的容器，-a 选项显示所有容器</td></tr><tr><td style="text-align:left;">pull</td><td style="text-align:left;">从镜像仓库拉取镜像</td></tr><tr><td style="text-align:left;">push</td><td style="text-align:left;">将镜像推送到镜像仓库</td></tr><tr><td style="text-align:left;">rm</td><td style="text-align:left;">删除已停止的容器，-f 选项可强制删除正在运行的容器</td></tr><tr><td style="text-align:left;">rmi</td><td style="text-align:left;">删除镜像(必须先删除该镜像构建的所有容器)</td></tr><tr><td style="text-align:left;">run</td><td style="text-align:left;">根据镜像生成并进入一个新的容器</td></tr><tr><td style="text-align:left;">save</td><td style="text-align:left;">打包本地镜像使用压缩包来完成迁移</td></tr><tr><td style="text-align:left;">search</td><td style="text-align:left;">查找镜像</td></tr><tr><td style="text-align:left;">tag</td><td style="text-align:left;">修改镜像tag</td></tr></tbody></table><h2 id="docker镜像" tabindex="-1"><a class="header-anchor" href="#docker镜像" aria-hidden="true">#</a> Docker镜像</h2><p>一种新型的应用打包、分发和运行机制。容器镜像将应用运行环境，包括代码、依赖库、工具、资源文件和元信息等，打包成一种操作系统发行版无关的不可变更软件包。</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227105144.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>容器镜像打包了整个容器运行依赖的环境，以避免依赖运行容器的服务器的操作系统，从而实现 “build once，run anywhere”。</li><li>容器镜像一旦构建完成，就变成 read only，成为不可变基础设施的一份子。</li><li>操作系统发行版无关，核心解决的是容器进程对操作系统包含的库、工具、配置的依赖。</li></ul><h3 id="docker镜像优势与分层结构" tabindex="-1"><a class="header-anchor" href="#docker镜像优势与分层结构" aria-hidden="true">#</a> Docker镜像优势与分层结构</h3><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227105244.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</li><li>镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的 base 镜像构建而来，</li><li>那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227105324.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>只有容器层是可写的，容器层下面的所有镜像层都是只读的</li><li>叠加文件系统：从上往下依次在各镜像层中查找文件</li><li>Copy-on-Write：只有当需要修改时才复制一份数据</li></ul><h2 id="镜像仓库介绍" tabindex="-1"><a class="header-anchor" href="#镜像仓库介绍" aria-hidden="true">#</a> 镜像仓库介绍</h2><p>容器镜像服务（Software Repository for Container，简称SWR）是一种支持镜像全生命周期管理的服务， 提供简单易用、安全可靠的镜像管理功能，可快速部署容器化服务。用户可以通过界面、社区CLI和原生API上传、下载和管理容器镜像</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227105826.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>核心功能：</p><ul><li>镜像全生命周期管理</li><li>私有镜像仓库</li><li>镜像源加速</li><li>镜像仓库触发器</li><li>镜像安全扫描</li></ul><h2 id="如何使用dockerfile进行镜像构建" tabindex="-1"><a class="header-anchor" href="#如何使用dockerfile进行镜像构建" aria-hidden="true">#</a> 如何使用Dockerfile进行镜像构建</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。Docker通过读取Dockerfile中的指令自动生成映像。可以使用在命令行中调用任何命令。Dockerfile 一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227105422.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="如何使用dockerfile进行构建" tabindex="-1"><a class="header-anchor" href="#如何使用dockerfile进行构建" aria-hidden="true">#</a> 如何使用Dockerfile进行构建？</h3><p>Demo内容：Weather Forecast是一款查询城市的天气信息的应用示例</p><ol><li>构建镜像</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-t</span> forecast:v1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>推送镜像到swr保存，用于下次实验</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> tag forecast:v2  仓库名称/jarvis/forecast:v2
<span class="token function">docker</span> push 仓库名称/jarvis/forecast:v2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">提示</p><p>推送之前要先登录仓库，执行docker login 仓库地址</p></div><h3 id="docker-build命令参数详细" tabindex="-1"><a class="header-anchor" href="#docker-build命令参数详细" aria-hidden="true">#</a> Docker build命令参数详细</h3><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227110500.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230227110512.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,55),r=[d];function n(s,o){return e(),l("div",null,r)}const g=t(a,[["render",n],["__file","02_container.html.vue"]]);export{g as default};
