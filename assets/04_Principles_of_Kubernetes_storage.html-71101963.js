import{ab as i,G as e,H as n,ad as a}from"./framework-894cff3a.js";const t={},s=a('<h1 id="云原生钻石课程-第4课-kubernetes存储架构原理深度剖析-上" tabindex="-1"><a class="header-anchor" href="#云原生钻石课程-第4课-kubernetes存储架构原理深度剖析-上" aria-hidden="true">#</a> 云原生钻石课程 | 第4课：Kubernetes存储架构原理深度剖析(上)</h1><p>从上节课(Kubernetes高级调度器原理详解)中我们了解了高级调度器的原理。K8s为适应不同需求的调度能力，提供了一套调度框架。在生产环境中，存储也是种类繁杂多样的：比如存储产品时不同存储提供商的产品存在差异性；存储性能时不同磁盘的性能存在差异性；存储地域时不同存储池所服务的地域不同等，面对复杂存储环境，k8s是如何应对的呢？这就是我们将要讨论的云原生存储体系。</p><h2 id="kubernetes容器存储发展历程" tabindex="-1"><a class="header-anchor" href="#kubernetes容器存储发展历程" aria-hidden="true">#</a> Kubernetes容器存储发展历程</h2><p>K8s初期为存算分离所做的解耦设计Volume，采用强耦合、灵活性差的in-tree模式，虽然已经让用户专注于业务功能设计。但这类存储卷的生命周期是跟随pod的，只能用作存储临时数据，无法做为最终数据使用。</p><p>随着k8s的不断成熟，为支持更多的应用场景，提供了一种脱离pod生命周期的、用户可管理的存储抽象设计低耦合、灵活性更强的<code>PersistentVolume/PersistentVolumeClaim</code>。</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228152318.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="kubernetes容器存储能力简介" tabindex="-1"><a class="header-anchor" href="#kubernetes容器存储能力简介" aria-hidden="true">#</a> Kubernetes容器存储能力简介</h2><p>主要包含三种类型：</p><h3 id="配置数据" tabindex="-1"><a class="header-anchor" href="#配置数据" aria-hidden="true">#</a> 配置数据</h3><ul><li><strong>ConfigMap</strong>：用于存储部署在Kubernetes的应用使用的配置数据，类似建议的配置中心。</li><li><strong>Secret</strong>：用于存储部署在Kubernetes的应用需要的敏感信息，比如密码、token、证书等，提供了一种安全和可扩展的机制。可作为具备加密的ConfigMap使用。</li><li><strong>Projected</strong>：用于汇聚多个不同卷资源，并挂载到同一个目录，当前支持的卷有：secret、configMap、downwardAPI和serviceAccountToken</li></ul><h3 id="临时存储" tabindex="-1"><a class="header-anchor" href="#临时存储" aria-hidden="true">#</a> 临时存储</h3><ul><li><strong>EmptyDir</strong>：emptyDir生命周期和POD保持一致，pod删除后，emptyDir中的数据也会被清除。</li><li><strong>HostPath</strong>：HostPath是将节点本地文件系统的路径映射到pod容器中，供程序使用。pod删除后，HostPath中的数据K8S不会被清除，依赖用户pod配置。</li><li><strong>In-tree的网络存储</strong>：网络存储跟随pod的生命周期，通过in-tree的存储插件对接不同类型存储；其中FlexVolume虽然允许不同厂商去开发他们自己的驱动来挂载卷到集群节点上供pod使用，但生命周期与pod同步。</li></ul><h3 id="持久存储声明" tabindex="-1"><a class="header-anchor" href="#持久存储声明" aria-hidden="true">#</a> 持久存储声明</h3><ul><li><strong>PersistentVolumeClaim（网络存储）</strong>：存储具有独立的生命周期，可以通过存储提供商提供的out-tree插件，对接其存储。当前支持的存储插件类型有FlexVolume和CSI。</li></ul><h2 id="kubernetes持久化存储体系" tabindex="-1"><a class="header-anchor" href="#kubernetes持久化存储体系" aria-hidden="true">#</a> Kubernetes持久化存储体系</h2><h3 id="kubernetes持久化存储体系介绍" tabindex="-1"><a class="header-anchor" href="#kubernetes持久化存储体系介绍" aria-hidden="true">#</a> Kubernetes持久化存储体系介绍</h3><p><strong>K8s持久化存储体系包括</strong>：</p><ul><li><strong>PersistentVolume</strong>：简称pv，持久化存储，是k8s为云原生应用提供一种拥有独立生命周期的、用户可管理的存储抽象设计</li><li><strong>PersistentVolumeClaim</strong>：简称pvc，持久化存储声明，是K8S为解耦云原生应用和数据存储而设计的，通过PVC可以让资源管控更细更灵活、团队职责分离、应用模板更通用，进一步解除了用户被云平台锁定的顾虑。</li><li><strong>StorageClass</strong>：简称sc，存储类，是K8S平台为存储提供商提供存储接入的一种声明，通过sc和相应的存储插件(csi)为容器应用提供动态分配存储卷的能力；</li><li><strong>Driver Plugin</strong>：存储驱驱动插件，由存储提供商提供，能够对接网络存储，并管理持久存储卷的生命周期。</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228152645.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="持久化存储优势分析" tabindex="-1"><a class="header-anchor" href="#持久化存储优势分析" aria-hidden="true">#</a> 持久化存储优势分析</h3><p>与临时存储相比，PV具有：</p><ul><li>每个存储卷可以拥有独立的生命周期，不再跟随pod创建和销毁；</li><li>使能计算+数据的迁移，也即：存储卷中的数据可以随pod在集群中迁移；</li><li>多个不同的pod可以共享同一个存储卷（存储卷支持共享）；</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228152724.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>引入PVC/SC后，带来更大的收益：</p><ul><li>资源管控更加灵活，可适应资源管控严格、宽松的不同场景；</li><li>团队职责更加明确，开发人员只需考虑存储需求(IO、容量、访问模式等)，不需要关注存储类型，甚至品牌；</li><li>灵活的扩展一些增强功能，比如：扩容、快照能力；</li><li>应用模板更加通用，可通过参数配置，适应不同类型的k8s平台；</li><li>进一步消除用户被存储提供商、云平台锁定的顾虑。</li></ul><h2 id="pv-pvc的工作原理剖析" tabindex="-1"><a class="header-anchor" href="#pv-pvc的工作原理剖析" aria-hidden="true">#</a> PV/PVC的工作原理剖析</h2><p><strong>pv/pvc的分配方式如图示</strong></p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228152850.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>静态卷：Volum先有资源，然后通过pv绑定与关联资源，再通过pvc去绑定pv，此时应用可通过pvc使用volum。</p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228152925.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>动态卷：pvc先声明，再指定SC,通过pvc与SC最终创建出volum，此时pvc与pv绑定，从而为用户和应用提供存储服务。</p><p><strong>静态卷：pv的状态转换</strong></p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153113.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>静态卷：pvc的状态转换</strong></p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153200.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>pv/pvc绑定原理分析</strong></p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153225.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>pvc刷选pv的流程（findBestMatchForClaim）：</p><ul><li>通过size刷选恰当的pv；</li><li>通过volumeMode刷选一致的pv；</li><li>通过Label刷选合适的pv；</li><li>通过sc刷选符合的pv；</li><li>通过AccessMode刷选符合条件的pv；</li><li>返回并绑定符合pvc条件，且size最小的pv。</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153419.png" alt="pvc绑定pv流程解读" tabindex="0" loading="lazy"><figcaption>pvc绑定pv流程解读</figcaption></figure><p><strong>Kubernetes中pv/pvc相关的代码</strong></p><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153504.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>静态卷：pv/pvc使用场景示例</strong></p><p>pv/pvc适合在资源管理比较严格的场景：</p><ul><li>开发人员向集群管理员申请存储需求；</li><li>存储管理员按需求分配存储；</li><li>集群管理员按照分配的存储创建pv；</li><li>开发人员创建pvc，pvc关联合适的pv；</li><li>开发人员创建pod，并且pod使用pvc。</li></ul><figure><img src="https://didiplus.oss-cn-hangzhou.aliyuncs.com/20230228153547.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',46),r=[s];function o(l,p){return e(),n("div",null,r)}const g=i(t,[["render",o],["__file","04_Principles_of_Kubernetes_storage.html.vue"]]);export{g as default};
