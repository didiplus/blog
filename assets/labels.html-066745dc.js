import{ab as l,G as d,H as p,E as e,S as n,N as a,ac as s,ad as o,W as i}from"./framework-b31a425c.js";const r={},u=o(`<h1 id="_3-2-5、标签和选择器" tabindex="-1"><a class="header-anchor" href="#_3-2-5、标签和选择器" aria-hidden="true">#</a> 3.2.5、标签和选择器</h1><p>标签（Label）是附加在Kubernetes对象上的一组名值对，其意图是按照对用户有意义的方式来标识Kubernetes对象，同时，又不对Kubernetes的核心逻辑产生影响。标签可以用来组织和选择一组Kubernetes对象。您可以在创建Kubernetes对象时为其添加标签，也可以在创建以后再为其添加标签。每个Kubernetes对象可以有多个标签，同一个对象的标签的 <strong>Key必须唯一</strong>，例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">key1</span><span class="token punctuation">:</span> value1
    <span class="token key atrule">key2</span><span class="token punctuation">:</span> value2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),k={class:"table-of-contents"},v=o(`<h2 id="为什么要使用标签" tabindex="-1"><a class="header-anchor" href="#为什么要使用标签" aria-hidden="true">#</a> 为什么要使用标签</h2><p>使用标签，用户可以按照自己期望的形式组织 Kubernetes 对象之间的结构，而无需对 Kubernetes 有任何修改。</p><p>应用程序的部署或者批处理程序的部署通常都是多维度的（例如，多个高可用分区、多个程序版本、多个微服务分层）。管理这些对象时，很多时候要针对某一个维度的条件做整体操作，例如，将某个版本的程序整体删除，这种情况下，如果用户能够事先规划好标签的使用，再通过标签进行选择，就会非常地便捷。</p><p>标签的例子有：</p><ul><li><code>release: stable</code>、<code>release: canary</code></li><li><code>environment: dev</code>、<code>environment: qa</code>、<code>environment: production</code></li><li><code>tier: frontend</code>、<code>tier: backend</code>、<code>tier: cache</code></li><li><code>partition: customerA</code>、<code>partition: customerB</code></li><li><code>track: daily</code>、<code>track: weekly</code></li></ul><p>上面只是一些使用比较普遍的标签，您可以根据您自己的情况建立合适的使用标签的约定。</p><h2 id="句法和字符集" tabindex="-1"><a class="header-anchor" href="#句法和字符集" aria-hidden="true">#</a> 句法和字符集</h2><p>标签是一组名值对（key/value pair）。标签的 key 可以有两个部分：可选的前缀和标签名，通过 <code>/</code> 分隔。</p><ul><li>标签名： <ul><li>标签名部分是必须的</li><li>不能多于 63 个字符</li><li>必须由字母、数字开始和结尾</li><li>可以包含字母、数字、减号<code>-</code>、下划线<code>_</code>、小数点<code>.</code></li></ul></li><li>标签前缀： <ul><li>标签前缀部分是可选的</li><li>如果指定，必须是一个DNS的子域名，例如：k8s.eip.work</li><li>不能多于 253 个字符</li><li>使用 <code>/</code> 和标签名分隔</li></ul></li></ul><p>如果省略标签前缀，则标签的 key 将被认为是专属于用户的。Kubernetes的系统组件（例如，kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方组件）向用户的Kubernetes对象添加标签时，必须指定一个前缀。</p><p><code>kubernetes.io/</code> 和 <code>k8s.io/</code> 这两个前缀是 Kubernetes 核心组件预留的。Kuboard 使用 <code>k8s.eip.work</code> 这个前缀。</p><p>标签的 value 必须：</p><ul><li>不能多于 63 个字符</li><li>可以为空字符串</li><li>如果不为空，则 <ul><li>必须由字母、数字开始和结尾</li><li>可以包含字母、数字、减号<code>-</code>、下划线<code>_</code>、小数点<code>.</code></li></ul></li></ul><p>例如，下面的例子中的Pod包含两个标签 <code>environment: production</code> 和 <code>app:nginx</code></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> label<span class="token punctuation">-</span>demo
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span> production
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="标签选择器" tabindex="-1"><a class="header-anchor" href="#标签选择器" aria-hidden="true">#</a> 标签选择器</h2>`,16),m=o('<p>Kubernetes api server支持两种形式的标签选择器，<code>equality-based 基于等式的</code> 和 <code>set-based 基于集合的</code>。标签选择器可以包含多个条件，并使用逗号分隔，此时只有满足所有条件的 Kubernetes 对象才会被选中。</p><p>如果使用空的标签选择器或者不指定选择器，其含义由具体的 API 接口决定。</p><h3 id="基于等式的选择方式" tabindex="-1"><a class="header-anchor" href="#基于等式的选择方式" aria-hidden="true">#</a> 基于等式的选择方式</h3><p>Equality- 或者 inequality-based 选择器可以使用标签的名和值来执行过滤选择。只有匹配所有条件的对象才被选中（被选中的对象可以包含未指定的标签）。可以使用三种操作符 <code>=</code>、<code>==</code>、<code>!=</code>。前两个操作符含义是一样的，都代表相等，后一个操作符代表不相等。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 选择了标签名为 `environment` 且 标签值为 `production` 的Kubernetes对象</span>\nenvironment <span class="token operator">=</span> production\n<span class="token comment"># 选择了标签名为 `tier` 且标签值不等于 `frontend` 的对象，以及不包含标签 `tier` 的对象</span>\ntier <span class="token operator">!=</span> frontend\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用逗号分隔的两个等式 <code>environment=production,tier!=frontend</code>，此时将选中所有 <code>environment</code> 为 <code>production</code> 且 <code>tier</code> 不为 <code>frontend</code> 的对象。</p>',6),b=e("code",null,"accelerator=nvidia-tesla-p100",-1),h=o(`<div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> cuda<span class="token punctuation">-</span>test
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cuda<span class="token punctuation">-</span>test
      <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span>
      <span class="token key atrule">resources</span><span class="token punctuation">:</span>
        <span class="token key atrule">limits</span><span class="token punctuation">:</span>
          <span class="token key atrule">nvidia.com/gpu</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>
    <span class="token key atrule">accelerator</span><span class="token punctuation">:</span> nvidia<span class="token punctuation">-</span>tesla<span class="token punctuation">-</span>p100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基于集合的选择方式" tabindex="-1"><a class="header-anchor" href="#基于集合的选择方式" aria-hidden="true">#</a> 基于集合的选择方式</h3><p>Set-based 标签选择器可以根据标签名的一组值进行筛选。支持的操作符有三种：<code>in</code>、<code>notin</code>、<code>exists</code>。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 选择所有的包含 \`environment\` 标签且值为 \`production\` 或 \`qa\` 的对象</span>
environment <span class="token keyword">in</span> <span class="token punctuation">(</span>production, qa<span class="token punctuation">)</span>
<span class="token comment"># 选择所有的 \`tier\` 标签不为 \`frontend\` 和 \`backend\`的对象，或不含 \`tier\` 标签的对象</span>
tier notin <span class="token punctuation">(</span>frontend, backend<span class="token punctuation">)</span>
<span class="token comment"># 选择所有包含 \`partition\` 标签的对象</span>
partition
<span class="token comment"># 选择所有不包含 \`partition\` 标签的对象</span>
<span class="token operator">!</span>partition
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以组合多个选择器，用 <code>,</code> 分隔，<code>,</code> 相当于 <code>AND</code> 操作符。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 选择包含 \`partition\` 标签（不检查标签值）且 \`environment\` 不是 \`qa\` 的对象</span>
partition,environment notin <span class="token punctuation">(</span>qa<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>基于集合的选择方式是一个更宽泛的基于等式的选择方式，例如，<code>environment=production</code> 等价于 <code>environment in (production)</code>；<code>environment!=production</code> 等价于 <code>environment notin (production)</code>。</p><p>基于集合的选择方式可以和基于等式的选择方式可以混合使用，例如： <code>partition in (customerA, customerB),environment!=qa</code></p><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h2><h3 id="查询条件" tabindex="-1"><a class="header-anchor" href="#查询条件" aria-hidden="true">#</a> 查询条件</h3><p>LIST 和 WATCH 操作时，可指定标签选择器作为查询条件，以筛选指定的对象集合。两种选择方式都可以使用，但是要符合 URL 编码，例如：</p><ul><li>基于等式的选择方式： <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>基于集合的选择方式： <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>两种选择方式都可以在 kubectl 的 list 和 watch 命令中使用，例如：</p><ul><li>使用基于等式的选择方式<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get pods <span class="token parameter variable">-l</span> <span class="token assign-left variable">environment</span><span class="token operator">=</span>production,tier<span class="token operator">=</span>frontend
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>使用基于集合的选择方式<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl get pods <span class="token parameter variable">-l</span> <span class="token string">&#39;environment in (production),tier in (frontend)&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="kubernetes对象引用" tabindex="-1"><a class="header-anchor" href="#kubernetes对象引用" aria-hidden="true">#</a> Kubernetes对象引用</h3><p>某些 Kubernetes 对象中（例如，Service和Deployment），使用标签选择器指定一组其他类型的 Kubernetes 对象（例如，Pod）</p><h4 id="service" tabindex="-1"><a class="header-anchor" href="#service" aria-hidden="true">#</a> Service</h4><p>Service 中通过 <code>spec.selector</code> 字段来选择一组 Pod，并将服务请求转发到选中的 Pod 上。</p><p>在 yaml 或 json 文件中，标签选择器用一个 map 来定义，且支持基于等式的选择方式，例如：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token property">&quot;selector&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;component&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;redis&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">selector</span><span class="token punctuation">:</span>
  <span class="token key atrule">component</span><span class="token punctuation">:</span> redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中定义的标签选择器等价于 <code>component=redis</code> 或 <code>component in (redis)</code></p><h4 id="有些对象支持基于集合的选择方式" tabindex="-1"><a class="header-anchor" href="#有些对象支持基于集合的选择方式" aria-hidden="true">#</a> 有些对象支持基于集合的选择方式</h4><p><code>Job</code>、<code>Deployment</code>、<code>ReplicaSet</code> 和 <code>DaemonSet</code> 同时支持基于等式的选择方式和基于集合的选择方式。例如：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">selector</span><span class="token punctuation">:</span>
  <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>
    <span class="token key atrule">component</span><span class="token punctuation">:</span> redis
  <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">key</span><span class="token punctuation">:</span> tier<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cache<span class="token punctuation">]</span><span class="token punctuation">}</span>
    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">key</span><span class="token punctuation">:</span> environment<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> NotIn<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>dev<span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>matchLabels</code> 是一个 {key,value} 组成的 map。map 中的一个 {key,value} 条目相当于 <code>matchExpressions</code> 中的一个元素，其 <code>key</code> 为 map 的 key，<code>operator</code> 为 <code>In</code>， <code>values</code> 数组则只包含 <code>value</code> 一个元素。<code>matchExpression</code> 等价于基于集合的选择方式，支持的 <code>operator</code> 有 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。当 <code>operator</code> 为 <code>In</code> 或 <code>NotIn</code> 时，<code>values</code> 数组不能为空。所有的选择条件都以 AND 的形式合并计算，即所有的条件都满足才可以算是匹配。</p><h4 id="引用一组节点" tabindex="-1"><a class="header-anchor" href="#引用一组节点" aria-hidden="true">#</a> 引用一组节点</h4><p>可以通过标签选择器将 Pod 调度到指定的节点上，请参考 <a href="">将容器组调度到指定的节点</a></p>`,29);function y(g,f){const c=i("RouterLink"),t=i("router-link");return d(),p("div",null,[u,e("p",null,[n("使用标签（Label）可以高效地查询和监听Kubernetes对象，在Kubernetes界面工具（如 Kubenetes Dashboard 或 Kuboard）和 kubectl 中，标签的使用非常普遍。那些非标识性的信息应该记录在"),a(c,{to:"/cloud/k8s/k8s-intermediate/obj/annotations.html"},{default:s(()=>[n("注解（annotation）")]),_:1})]),e("nav",k,[e("ul",null,[e("li",null,[a(t,{to:"#为什么要使用标签"},{default:s(()=>[n("为什么要使用标签")]),_:1})]),e("li",null,[a(t,{to:"#句法和字符集"},{default:s(()=>[n("句法和字符集")]),_:1})]),e("li",null,[a(t,{to:"#标签选择器"},{default:s(()=>[n("标签选择器")]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#基于等式的选择方式"},{default:s(()=>[n("基于等式的选择方式")]),_:1})]),e("li",null,[a(t,{to:"#基于集合的选择方式"},{default:s(()=>[n("基于集合的选择方式")]),_:1})])])]),e("li",null,[a(t,{to:"#api"},{default:s(()=>[n("API")]),_:1}),e("ul",null,[e("li",null,[a(t,{to:"#查询条件"},{default:s(()=>[n("查询条件")]),_:1})]),e("li",null,[a(t,{to:"#kubernetes对象引用"},{default:s(()=>[n("Kubernetes对象引用")]),_:1})])])])])]),v,e("p",null,[n("与 "),a(c,{to:"/cloud/k8s/k8s-intermediate/obj/names.html"},{default:s(()=>[n("name 和 UID")]),_:1}),n(" 不同，标签不一定是唯一的。通常来讲，会有多个Kubernetes对象包含相同的标签。通过使用标签选择器（label selector），用户/客户端可以选择一组对象。标签选择器（label selector）是 Kubernetes 中最主要的分类和筛选手段。")]),m,e("p",null,[n("以 "),a(c,{to:"/learning/k8s-intermediate/config/assign-pod-node.html#%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E5%99%A8-nodeselector"},{default:s(()=>[n("Pod 的节点选择器")]),_:1}),n(" 为例，下面的 Pod 可以被调度到包含标签 "),b,n(" 的节点上：")]),h])}const x=l(r,[["render",y],["__file","labels.html.vue"]]);export{x as default};
