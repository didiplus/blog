import{ab as d,G as c,H as u,E as e,S as r,N as t,ac as a,L as l,ad as i,W as s}from"./framework-894cff3a.js";const h={},b=e("h1",{id:"_1-2、kubernetes组件",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-2、kubernetes组件","aria-hidden":"true"},"#"),r(" 1.2、Kubernetes组件")],-1),p={href:"https://kubernetes.io/docs/concepts/overview/components/",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"本文档描述了 Kubernetes 的主要组件。",-1),k=e("h2",{id:"master组件",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#master组件","aria-hidden":"true"},"#"),r(" Master组件")],-1),m=e("p",null,"Master组件是集群的控制平台（control plane）：",-1),f=e("ul",null,[e("li",null,"master 组件负责集群中的全局决策（例如，调度）"),e("li",null,[r("master 组件探测并响应集群事件（例如，当 Deployment 的实际 Pod 副本数未达到 "),e("code",null,"replicas"),r(" 字段的规定时，启动一个新的 Pod）")])],-1),g=e("h3",{id:"kube-apiserver",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kube-apiserver","aria-hidden":"true"},"#"),r(" kube-apiserver")],-1),K=e("p",null,"此 master 组件提供 Kubernetes API。这是Kubernetes控制平台的前端（front-end），可以水平扩展（通过部署更多的实例以达到性能要求）。kubectl / kubernetes dashboard / kuboard 等Kubernetes管理工具就是通过 kubernetes API 实现对 Kubernetes 集群的管理。",-1),v=e("h3",{id:"etcd",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#etcd","aria-hidden":"true"},"#"),r(" etcd")],-1),x={href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster",target:"_blank",rel:"noopener noreferrer"},E={href:"https://etcd.io/docs/",target:"_blank",rel:"noopener noreferrer"},S=i('<h3 id="kube-scheduler" tabindex="-1"><a class="header-anchor" href="#kube-scheduler" aria-hidden="true">#</a> kube-scheduler</h3><p>此 master 组件监控所有新创建尚未分配到节点上的 Pod，并且自动选择为 Pod 选择一个合适的节点去运行。</p><p>影响调度的因素有：</p><ul><li>单个或多个 Pod 的资源需求</li><li>硬件、软件、策略的限制</li><li>亲和与反亲和（affinity and anti-affinity）的约定</li><li>数据本地化要求</li><li>工作负载间的相互作用</li></ul><h3 id="kube-controller-manager" tabindex="-1"><a class="header-anchor" href="#kube-controller-manager" aria-hidden="true">#</a> kube-controller-manager</h3><p>此 master 组件运行了所有的控制器</p><p>逻辑上来说，每一个控制器是一个独立的进程，但是为了降低复杂度，这些控制器都被合并运行在一个进程里。</p><p>kube-controller-manager 中包含的控制器有：</p><ul><li>节点控制器： 负责监听节点停机的事件并作出对应响应</li><li>副本控制器： 负责为集群中每一个 副本控制器对象（Replication Controller Object）维护期望的 Pod 副本数</li><li>端点（Endpoints）控制器：负责为端点对象（Endpoints Object，连接 Service 和 Pod）赋值</li><li>Service Account &amp; Token控制器： 负责为新的名称空间创建 default Service Account 以及 API Access Token</li></ul><h3 id="cloud-controller-manager" tabindex="-1"><a class="header-anchor" href="#cloud-controller-manager" aria-hidden="true">#</a> cloud-controller-manager</h3><p>cloud-controller-manager 中运行了与具体云基础设施供应商互动的控制器。这是 Kubernetes 1.6 版本中引入的特性，尚处在 alpha 阶段。</p>',11),w={href:"http://www.kuboard.cn",target:"_blank",rel:"noopener noreferrer"},A=e("p",null,"cloud-controller-manager 使得云供应商的代码和 Kubernetes 的代码可以各自独立的演化。在此之前的版本中，Kubernetes的核心代码是依赖于云供应商的代码的。在后续的版本中，特定于云供应商的代码将由云供应商自行维护，并在运行Kubernetes时链接到 cloud-controller-manager。",-1),N=e("p",null,"以下控制器中包含与云供应商相关的依赖：",-1),D=e("li",null,[r("节点控制器：当某一个节点停止响应时，调用云供应商的接口，以检查该节点的虚拟机是否已经被云供应商删除 "),e("blockquote",null,[e("p",null,[r("译者注：私有化部署Kubernetes时，我们不知道节点的操作系统是否删除，所以在移除节点后，要自行通过 "),e("code",null,"kubectl delete node"),r(" 将节点对象从 Kubernetes 中删除")])])],-1),C=e("li",null,[r("服务（Service）控制器：创建、更新、删除云供应商提供的负载均衡器 "),e("blockquote",null,[e("p",null,"译者注：私有化部署Kubernetes时，不支持 LoadBalancer 类型的 Service，如需要此特性，需要创建 NodePort 类型的 Service，并自行配置负载均衡器")])],-1),P=i('<blockquote><p>译者注：通过 cloud-controller-manager，Kubernetes可以更好地与云供应商结合，例如，在阿里云的 Kubernetes 服务里，您可以在云控制台界面上轻松点击鼠标，即可完成 Kubernetes 集群的创建和管理。在私有化部署环境时，您必须自行处理更多的内容。幸运的是，通过合适的教程指引，这些任务的达成并不困难。</p></blockquote><h2 id="node-组件" tabindex="-1"><a class="header-anchor" href="#node-组件" aria-hidden="true">#</a> Node 组件</h2><p>Node 组件运行在每一个节点上（包括 master 节点和 worker 节点），负责维护运行中的 Pod 并提供 Kubernetes 运行时环境。</p><h3 id="kubelet" tabindex="-1"><a class="header-anchor" href="#kubelet" aria-hidden="true">#</a> kubelet</h3><p>此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。</p><h3 id="kube-proxy" tabindex="-1"><a class="header-anchor" href="#kube-proxy" aria-hidden="true">#</a> kube-proxy</h3>',6),y=e("h3",{id:"容器引擎",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#容器引擎","aria-hidden":"true"},"#"),r(" 容器引擎")],-1),B={href:"http://www.docker.com/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://containerd.io/",target:"_blank",rel:"noopener noreferrer"},q={href:"https://cri-o.io/",target:"_blank",rel:"noopener noreferrer"},L={href:"https://github.com/kubernetes-incubator/rktlet",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md",target:"_blank",rel:"noopener noreferrer"},V=e("h2",{id:"addons",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#addons","aria-hidden":"true"},"#"),r(" Addons")],-1),F=e("p",null,[r("Addons 使用 Kubernetes 资源（DaemonSet、Deployment等）实现集群的功能特性。由于他们提供集群级别的功能特性，addons使用到的Kubernetes资源都放置在 "),e("code",null,"kube-system"),r(" 名称空间下。")],-1),R={href:"https://kubernetes.io/docs/concepts/cluster-administration/addons/",target:"_blank",rel:"noopener noreferrer"},T=e("h3",{id:"dns",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dns","aria-hidden":"true"},"#"),r(" DNS")],-1),U=e("p",null,"Cluster DNS 是一个 DNS 服务器，是对您已有环境中其他 DNS 服务器的一个补充，存放了 Kubernetes Service 的 DNS 记录。",-1),W=e("p",null,"Kubernetes 启动容器时，自动将该 DNS 服务器加入到容器的 DNS 搜索列表中。",-1),j={href:"http://www.kuboard.cn",target:"_blank",rel:"noopener noreferrer"},O={href:"https://coredns.io/",target:"_blank",rel:"noopener noreferrer"},X=e("h3",{id:"web-ui-dashboard",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#web-ui-dashboard","aria-hidden":"true"},"#"),r(" Web UI（Dashboard）")],-1),G={href:"https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/",target:"_blank",rel:"noopener noreferrer"},H=e("h3",{id:"kuboard",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kuboard","aria-hidden":"true"},"#"),r(" Kuboard")],-1),Y=e("ul",null,[e("li",null,"无需手工编写 YAML 文件"),e("li",null,"微服务参考架构"),e("li",null,"上下文相关的监控"),e("li",null,[r("场景化的设计 "),e("ul",null,[e("li",null,"导出配置"),e("li",null,"导入配置")])])],-1),z=e("h3",{id:"containerresource-monitoring",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#containerresource-monitoring","aria-hidden":"true"},"#"),r(" ContainerResource Monitoring")],-1),J={href:"https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/",target:"_blank",rel:"noopener noreferrer"},Q=e("h3",{id:"cluster-level-logging",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#cluster-level-logging","aria-hidden":"true"},"#"),r(" Cluster-level Logging")],-1),Z={href:"https://kubernetes.io/docs/concepts/cluster-administration/logging/",target:"_blank",rel:"noopener noreferrer"};function $(ee,re){const n=s("ExternalLinkIcon"),o=s("RouterLink");return c(),u("div",null,[b,e("blockquote",null,[e("p",null,[r("参考文档： "),e("a",p,[r("Kubernetes Components"),t(n)])])]),_,k,m,f,e("p",null,[r("Master组件可以运行于集群中的任何机器上。但是，为了简洁性，通常在同一台机器上运行所有的 master 组件，且不在此机器上运行用户的容器。参考 "),t(o,{to:"/cloud/k8s/install/install-kubernetes.html"},{default:a(()=>[r("安装Kubernetes高可用")]),_:1}),r("。")]),g,K,v,e("p",null,[r("支持一致性和高可用的名值对存储组件，Kubernetes集群的所有配置信息都存储在 etcd 中。请确保您 "),e("a",x,[r("备份"),t(n)]),r(" 了 etcd 的数据。关于 etcd 的更多信息，可参考 "),e("a",E,[r("etcd 官方文档"),t(n)])]),S,e("p",null,[r("cloud-controller-manager 只运行特定于云基础设施供应商的控制器。如果您参考 "),e("a",w,[r("www.kuboard.cn"),t(n)]),r(" 上提供的文档安装 Kubernetes 集群，默认不安装 cloud-controller-manager。")]),A,N,e("ul",null,[D,e("li",null,[r("路由控制器：在云供应商的基础设施中设定网络路由 "),e("blockquote",null,[e("p",null,[r("译者注：私有化部署Kubernetes时，需要自行规划Kubernetes的拓扑结构，并做好路由配置，例如 "),t(o,{to:"/cloud/k8s/install/install-k8s.html"},{default:a(()=>[r("离线安装高可用的Kubernetes集群")]),_:1}),r(" 中所作的")])])]),C,e("li",null,[r("数据卷（Volume）控制器：创建、绑定、挂载数据卷，并协调云供应商编排数据卷 "),e("blockquote",null,[e("p",null,[r("译者注：私有化部署Kubernetes时，需要自行创建和管理存储资源，并通过Kubernetes的"),t(o,{to:"/learning/k8s-intermediate/persistent/storage-class.html"},{default:a(()=>[r("存储类")]),_:1}),r("、"),t(o,{to:"/learning/k8s-intermediate/persistent/pv.html"},{default:a(()=>[r("存储卷")]),_:1}),r("、"),t(o,{to:"/learning/k8s-intermediate/persistent/volume.html"},{default:a(()=>[r("数据卷")]),_:1}),r("等与之关联")])])])]),P,e("p",null,[t(o,{to:"/learning/k8s-intermediate/service/service-details.html#%E8%99%9A%E6%8B%9F-ip-%E5%92%8C%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86"},{default:a(()=>[r("kube-proxy")]),_:1}),r(" 是一个网络代理程序，运行在集群中的每一个节点上，是实现 Kubernetes Service 概念的重要部分。")]),e("p",null,[r("kube-proxy 在节点上维护网络规则。这些网络规则使得您可以在集群内、集群外正确地与 Pod 进行网络通信。如果操作系统中存在 packet filtering layer，kube-proxy 将使用这一特性（"),t(o,{to:"/learning/k8s-intermediate/service/service-details.html#iptables-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"},{default:a(()=>[r("iptables代理模式")]),_:1}),r("），否则，kube-proxy将自行转发网络请求（"),t(o,{to:"/learning/k8s-intermediate/service/service-details.html#user-space-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"},{default:a(()=>[r("User space代理模式")]),_:1}),r("）")]),y,e("p",null,[r("容器引擎负责运行容器。Kubernetes支持多种容器引擎："),e("a",B,[r("Docker"),t(n)]),r("、"),e("a",I,[r("containerd"),t(n)]),r("、"),e("a",q,[r("cri-o"),t(n)]),r("、"),e("a",L,[r("rktlet"),t(n)]),r(" 以及任何实现了 "),e("a",M,[r("Kubernetes容器引擎接口"),t(n)]),r(" 的容器引擎")]),V,F,e("p",null,[r("下面描述了一些经常用到的 addons，参考 "),e("a",R,[r("Addons"),t(n)]),r(" 查看更多列表。")]),T,e("p",null,[r("除了 DNS Addon 以外，其他的 addon 都不是必须的，所有 Kubernetes 集群都应该有 "),t(o,{to:"/learning/k8s-intermediate/service/dns.html"},{default:a(()=>[r("Cluster DNS")]),_:1})]),U,W,e("blockquote",null,[e("p",null,[r("如果您参考 "),e("a",j,[r("www.kuboard.cn"),t(n)]),r(" 上提供的文档安装 Kubernetes，默认已经安装了 "),e("a",O,[r("Core DNS"),t(n)])])]),X,e("p",null,[e("a",G,[r("Dashboard"),t(n)]),r(" 是一个Kubernetes集群的 Web 管理界面。用户可以通过该界面管理集群。")]),H,e("p",null,[t(o,{to:"/install/v3/install.html"},{default:a(()=>[r("Kuboard")]),_:1}),r(" 是一款基于Kubernetes的微服务管理界面，相较于 Dashboard，Kuboard 强调：")]),Y,z,e("p",null,[e("a",J,[r("Container Resource Monitoring"),t(n)]),r(" 将容器的度量指标（metrics）记录在时间序列数据库中，并提供了 UI 界面查看这些数据")]),l(" FIXME "),Q,e("p",null,[e("a",Z,[r("Cluster-level logging"),t(n)]),r(" 机制负责将容器的日志存储到一个统一存储中，并提供搜索浏览的界面")]),l(" FIXME ")])}const ne=d(h,[["render",$],["__file","component.html.vue"]]);export{ne as default};
