import{ab as e,G as o,H as n,ad as d}from"./framework-b31a425c.js";const a={},t=d(`<h1 id="基于污点的驱逐-taintbasedeviction" tabindex="-1"><a class="header-anchor" href="#基于污点的驱逐-taintbasedeviction" aria-hidden="true">#</a> 基于污点的驱逐（TaintBasedEviction）</h1><p>在前面的章节中，我们描述了 <a href="">NoExecute</a> 的污点效果，该效果将对已经运行在节点上的 Pod 施加如下影响：</p><ul><li>不容忍该污点的 Pod 将立刻被驱逐</li><li>容忍该污点的 Pod 在未指定 <code>tolerationSeconds</code> 的情况下，将继续在该节点上运行</li><li>容忍该污点的 Pod 在指定了 <code>tolerationSeconds</code> 的情况下，将在指定时间超过时从节点上驱逐</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>tolerationSeconds</code> 字段可以理解为 Pod 容忍该污点的 <code>耐心</code>：</p><ul><li>超过指定的时间，则达到 Pod 忍耐的极限，Pod 离开所在节点</li><li>不指定 <code>tolerationSeconds</code>，则认为 Pod 对该污点的容忍是无期限的</li></ul></div><p>此外，自 kubernetes 1.6 以来，kubernetes 的节点控制器在碰到某些特定的条件时，将自动为节点添加污点。这类污点有：</p><ul><li><code>node.kubernetes.io/not-ready</code>： 节点未就绪。对应着 NodeCondition <code>Ready</code> 为 <code>False</code> 的情况</li><li><code>node.kubernetes.io/unreachable</code>： 节点不可触达。对应着 NodeCondition <code>Ready</code> 为 <code>Unknown</code> 的情况</li><li><code>node.kubernetes.io/out-of-disk</code>：节点磁盘空间已满</li><li><code>node.kubernetes.io/memory-pressure</code>：节点内存吃紧</li><li><code>node.kubernetes.io/disk-pressure</code>：节点磁盘吃紧</li><li><code>node.kubernetes.io/network-unavailable</code>：节点网络不可用</li><li><code>node.kubernetes.io/unschedulable</code>：节点不可调度</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>：如果 kubelet 是由 &quot;外部&quot; 云服务商启动的，该污点用来标识某个节点当前为不可用的状态。在“云控制器”（cloud-controller-manager）初始化这个节点以后，kubelet将此污点移除</li></ul><p>自 kubernetes 1.13 开始，上述特性被默认启用。</p><p>例如，某一个包含了大量本地状态的应用，在网络断开时，可能仍然想要在节点上停留比较长的时间，以等待网络能够恢复，而避免从节点上驱逐。此时，该 Pod 的容忍可能如下所示：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">tolerations</span><span class="token punctuation">:</span>
<span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> <span class="token string">&quot;node.kubernetes.io/unreachable&quot;</span>
  <span class="token key atrule">operator</span><span class="token punctuation">:</span> <span class="token string">&quot;Exists&quot;</span>
  <span class="token key atrule">effect</span><span class="token punctuation">:</span> <span class="token string">&quot;NoExecute&quot;</span>
  <span class="token key atrule">tolerationSeconds</span><span class="token punctuation">:</span> <span class="token number">6000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 Pod 没有 <code>node.kubernetes.io/not-ready</code> 容忍， Kubernetes 将自动为 Pod 添加一个 <code>tolerationSeconds=300</code> 的 <code>node.kubernetes.io/not-ready</code> 容忍。同样的，如果 Pod 没有 <code>node.kubernetes.io/unreachable</code> 容忍，Kubernetes 将自动为 Pod 添加一个 <code>tolerationSeconds=300</code> 的 <code>node.kubernetes.io/unreachable</code> 容忍</p><p>这类自动添加的容忍确保了 Pod 在节点发生 <code>not-ready</code> 和 <code>unreachable</code> 问题时，仍然在节点上保留 5 分钟。</p><p>DaemonSet Pod 相对特殊一些，他们在创建时就添加了不带 <code>tolerationSeconds</code> 的 <code>NoExecute</code> 效果的容忍，适用的污点有：</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>这将确保 DaemonSet Pod 始终不会被驱逐。</p>`,14),s=[t];function c(i,l){return o(),n("div",null,s)}const u=e(a,[["render",c],["__file","taint-based-evictions.html.vue"]]);export{u as default};
