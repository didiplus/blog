import{ab as r,G as i,H as c,E as o,S as e,N as n,ac as a,L as u,ad as t,W as l}from"./framework-b31a425c.js";const p={},h=t(`<h1 id="_3-1-2、节点管理" tabindex="-1"><a class="header-anchor" href="#_3-1-2、节点管理" aria-hidden="true">#</a> 3.1.2、节点管理</h1><p>与 Pod 和 Service 不一样，节点并不是由 Kubernetes 创建的，节点由云供应商（例如，Google Compute Engine、阿里云等）创建，或者节点已经存在于您的物理机/虚拟机的资源池。向 Kubernetes 中创建节点时，仅仅是创建了一个描述该节点的 API 对象。节点 API 对象创建成功后，Kubernetes将检查该节点是否有效。例如，假设您创建如下节点信息：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">kind</span><span class="token punctuation">:</span> Node
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">&quot;10.240.79.157&quot;</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">&quot;my-first-k8s-node&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),m=o("code",null,"metadata.name",-1),b=o("div",{class:"hint-container tip"},[o("p",{class:"hint-container-title"},"提示"),o("p",null,[e("Kubernetes 将保留无效的节点 API 对象，并不断地检查该节点是否有效。除非您使用 "),o("code",null,"kubectl delete node my-first-k8s-node"),e(" 命令删除该节点。")])],-1),k=o("h2",{id:"节点控制器-node-controller",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#节点控制器-node-controller","aria-hidden":"true"},"#"),e(" 节点控制器（Node Controller）")],-1),_=o("p",null,"节点控制器是一个负责管理节点的 Kubernetes master 组件。在节点的生命周期中，节点控制器起到了许多作用。",-1),v=o("strong",null,"首先",-1),g=o("strong",null,"第二",-1),f=t("<li><strong>第三</strong>，节点控制器监控节点的健康状况。当节点变得不可触达时（例如，由于节点已停机，节点控制器不再收到来自节点的心跳信号），节点控制器将节点API对象的 <code>NodeStatus</code> Condition 取值从 <code>NodeReady</code> 更新为 <code>Unknown</code>；然后在等待 <code>pod-eviction-timeout</code> 时间后，将节点上的所有 Pod 从节点驱逐。 <blockquote><ul><li>默认40秒未收到心跳，修改 <code>NodeStatus</code> Condition 为 <code>Unknown</code>；</li><li>默认 <code>pod-eviction-timeout</code> 为 5分钟</li><li>节点控制器每隔 <code>--node-monitor-period</code> 秒检查一次节点的状态</li></ul></blockquote></li>",1),P={href:"https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md",target:"_blank",rel:"noopener noreferrer"},E=o("code",null,"kube-node-lease",-1),A=o("code",null,"Lease",-1),N=o("code",null,"Lease",-1),y=t("<ul><li>每次节点向 master 发出心跳信号，NodeStatus 都将被更新</li><li>只有在 NodeStatus 发生改变，或者足够长的时间未接收到 NodeStatus 更新时，节点控制器才更新 node lease（默认为1分钟，比节点失联的超时时间40秒要更长）</li></ul><blockquote><p>由于 node lease 比 NodeStatus 更轻量级，该特性显著提高了节点心跳机制的效率，并使 Kubernetes 性能和可伸缩性得到了提升</p></blockquote><p>在 Kubernetes v1.4 中，优化了节点控制器的逻辑以便更好的处理大量节点不能触达 master 的情况（例如，master 出现网络故障）。主要的优化点在于，节点控制器在决定是否执行 Pod 驱逐的动作时，会检查集群中所有节点的状态。</p><p>大多数情况下，节点控制器限制了驱逐 Pod 的速率为 <code>--node-eviction-rate</code> （默认值是0.1）每秒，即节点控制器每 10 秒驱逐 1 个 Pod。</p><p>当节点所在的高可用区出现故障时，节点控制器驱逐 Pod 的方式将不一样。节点控制器驱逐Pod前，将检查高可用区里故障节点的百分比（<code>NodeReady</code> Condition 的值为 <code>Unknown</code> 或 <code>False</code>）：</p><ul><li>如果故障节点的比例不低于 <code>--unhealthy-zone-threshold</code>（默认为 0.55），则降低驱逐 Pod 的速率 <ul><li>如果集群规模较小（少于等于 <code>--large-cluster-size-threshold</code> 个节点，默认值为 50），则停止驱逐 Pod</li><li>如果集群规模大于 <code>--large-cluster-size-threshold</code> 个节点，则驱逐 Pod 的速率降低到 <code>--secondary-node-eviction-rate</code> （默认值为 0.01）每秒</li></ul></li></ul><p>针对每个高可用区使用这个策略的原因是，某一个高可用区可能与 master 隔开了，而其他高可用区仍然保持连接。如果您的集群并未分布在云供应商的多个高可用区上，此时，您只有一个高可用区（即整个集群）。</p><p>将集群的节点分布到多个高可用区最大的原因是，在某个高可用区出现整体故障时，可以将工作负载迁移到仍然健康的高可用区。因此，如果某个高可用区的所有节点都出现故障时，节点控制器仍然使用正常的驱逐 Pod 的速率（<code>--node-eviction-rate</code>）。</p><p>最极端的情况是，所有的高可用区都完全不可用（例如，集群中一个健康的节点都没有），此时节点控制器 master 节点的网络连接出现故障，并停止所有的驱逐 Pod 的动作，直到某些连接得到恢复。</p>",9),I=o("code",null,"NoExecute",-1),S=t('<p>自 Kubernetes v1.8 开始，节点控制器可以根据节点的 Condition 为节点添加污点，此特性处于 alpha 阶段</p><h2 id="节点自注册-self-registration" tabindex="-1"><a class="header-anchor" href="#节点自注册-self-registration" aria-hidden="true">#</a> 节点自注册（Self-Registration）</h2><p>如果 kubelet 的启动参数 <code>--register-node</code>为 true（默认为 true），kubelet 会尝试将自己注册到 API Server。kubelet自行注册时，将使用如下选项：</p><ul><li><code>--kubeconfig</code>：向 apiserver 进行认证时所用身份信息的路径</li><li><code>--cloud-provider</code>：向云供应商读取节点自身元数据</li><li><code>--register-node</code>：自动向 API Server 注册节点</li><li><code>--register-with-taints</code>：注册节点时，为节点添加污点（逗号分隔，格式为 &lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</li><li><code>--node-ip</code>：节点的 IP 地址</li><li><code>--node-labels</code>：注册节点时，为节点添加标签</li><li><code>--node-status-update-frequency</code>：向 master 节点发送心跳信息的时间间隔</li></ul>',4),x={href:"https://kubernetes.io/docs/reference/access-authn-authz/node/",target:"_blank",rel:"noopener noreferrer"},B={href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction",target:"_blank",rel:"noopener noreferrer"},C=t('<h2 id="手动管理节点" tabindex="-1"><a class="header-anchor" href="#手动管理节点" aria-hidden="true">#</a> 手动管理节点</h2><p>集群管理员可以创建和修改节点API对象。</p><p>如果管理员想要手工创建节点API对象，可以将 kubelet 的启动参数 <code>--register-node</code> 设置为 false。</p><p>管理员可以修改节点API对象（不管是否设置了 <code>--register-node</code> 参数）。可以修改的内容有：</p><ul><li>增加/减少标签</li><li>标记节点为不可调度（unschedulable）</li></ul>',5),K=t(`<p>执行如下命令可将节点标记为不可调度（unschedulable），此时将阻止新的 Pod 被调度到该节点上，但是不影响任何已经在该节点上运行的 Pod。这在准备重启节点之前非常有用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>kubectl cordon <span class="token variable">$NODENAME</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>DaemonSet Controller 创建的 Pod 将绕过 Kubernetes 调度器，并且忽略节点的 unschedulable 属性。因为我们假设 Daemons 守护进程属于节点，尽管该节点在准备重启前，已经排空了上面所有的应用程序。</p></div><h2 id="节点容量-node-capacity" tabindex="-1"><a class="header-anchor" href="#节点容量-node-capacity" aria-hidden="true">#</a> 节点容量（Node Capacity）</h2><p>节点API对象中描述了节点的容量（Capacity），例如，CPU数量、内存大小等信息。通常，节点在向 APIServer 注册的同时，在节点API对象里汇报了其容量（Capacity）。如果您 <a href="#%E6%89%8B%E5%8A%A8%E7%AE%A1%E7%90%86%E8%8A%82%E7%82%B9">手动管理节点</a>，您需要在添加节点时自己设置节点的容量。</p><p>Kubernetes 调度器在调度 Pod 到节点上时，将确保节点上有足够的资源。具体来说，调度器检查节点上所有容器的资源请求之和不大于节点的容量。此时，只能检查由 kubelet 启动的容器，不包括直接由容器引擎启动的容器，更不包括不在容器里运行的进程。</p>`,6),q={href:"https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved",target:"_blank",rel:"noopener noreferrer"};function L(R,z){const s=l("RouterLink"),d=l("ExternalLinkIcon");return i(),c("div",null,[h,o("p",null,[e("Kubernetes 在 APIServer 上创建一个节点 API 对象（节点的描述），并且基于 "),m,e(" 字段对节点进行健康检查。如果节点有效（"),n(s,{to:"/cloud/k8s/k8s-bg/component.html#node-%E7%BB%84%E4%BB%B6"},{default:a(()=>[e("节点组件")]),_:1}),e("正在运行），则可以向该节点调度 Pod；否则，该节点 API 对象将被忽略，直到节点变为有效状态。")]),b,k,_,o("ul",null,[o("li",null,[v,e("，节点控制器在注册节点时为节点分配 "),n(s,{to:"/glossary/cidr.html"},{default:a(()=>[e("CIDR")]),_:1}),e(" 地址块")]),o("li",null,[g,e("，节点控制器通过云供应商（"),n(s,{to:"/cloud/k8s/k8s-intermediate/k8s-bg/component.html#cloud-controller-manager"},{default:a(()=>[e("cloud-controller-manager")]),_:1}),e("）接口检查节点列表中每一个节点对象对应的虚拟机是否可用。在云环境中，只要节点状态异常，节点控制器检查其虚拟机在云供应商的状态，如果虚拟机不可用，自动将节点对象从 APIServer 中删除。")]),f]),o("p",null,[e("在 Kubernetes v1.13 以前，NodeStatus 记录了从节点发出的心跳信号。从 Kubernetes v1.13 开始，node lease 特性进入 alpha 阶段（"),o("a",P,[e("KEP-0009"),n(d)]),e("）。当 node lease 特性被启用时，每个节点都有一个 "),E,e(" 名称空间下对应的 "),A,e(" 对象，节点控制器周期性地更新 "),N,e(" 对象；此时 NodeStatus 和 node lease 都被用来记录节点的心跳信号。NodeStatus 的更新频率远高于 node lease，原因是：")]),y,o("p",null,[e("自 Kubernetes v1.6 开始，节点控制器同时也负责为带有 "),I,e(" 污点的节点驱逐其上的 Pod。此外，节点控制器还负责根据节点的状态（例如，节点不可用，节点未就绪等）为节点添加污点。参考 "),n(s,{to:"/cloud/k8s/k8s-intermediate/config/taints-toleration/taints-toleration/#%E6%B1%A1%E7%82%B9%E4%B8%8E%E5%AE%B9%E5%BF%8D%E7%9A%84%E5%8C%B9%E9%85%8D"},{default:a(()=>[e("NoExecute")]),_:1}),e(" 获取更多信息。")]),S,o("p",null,[e("如果 "),o("a",x,[e("Node authorization mode"),n(d)]),e(" 和 "),o("a",B,[e("NodeRestriction admission plugin"),n(d)]),e(" 被启用，kubelet 只拥有创建/修改其自身所对应的节点 API 对象的权限。")]),C,o("p",null,[e("节点的标签与 Pod 上的节点选择器（node selector）配合，可以控制调度方式，例如，限定 Pod 只能在某一组节点上运行。请参考 "),n(s,{to:"/learning/k8s-intermediate/config/assign-pod-node.html"},{default:a(()=>[e("将容器组调度到指定的节点")]),_:1}),e("。")]),K,o("p",null,[e("如果您想显式地为 Pod 以外的进程预留资源，请参考 "),o("a",q,[e("reserve resources for system daemons"),n(d)])]),u(" FIXME ")])}const V=r(p,[["render",L],["__file","nodes-mgmt.html.vue"]]);export{V as default};
