import{_ as s,c as i,o as n,U as a}from"./chunks/framework.y0HOe2qR.js";const F=JSON.parse('{"title":"3.21 用了 TCP 协议，数据一定不会丢吗？","description":"","frontmatter":{},"headers":[],"relativePath":"datacom/network/3_tcp/3.21.tcp_drop.md","filePath":"datacom/network/3_tcp/3.21.tcp_drop.md","lastUpdated":1705029886000}'),p={name:"datacom/network/3_tcp/3.21.tcp_drop.md"},t=a(`<h1 id="_3-21-用了-tcp-协议-数据一定不会丢吗" tabindex="-1">3.21 用了 TCP 协议，数据一定不会丢吗？ <a class="header-anchor" href="#_3-21-用了-tcp-协议-数据一定不会丢吗" aria-label="Permalink to &quot;3.21 用了 TCP 协议，数据一定不会丢吗？&quot;">​</a></h1><blockquote><p>来源：公众号@小白debug</p><p>原文地址：<a href="https://mp.weixin.qq.com/s/XNJoaVnYT1SxHsdNWeAaUw" target="_blank" rel="noreferrer">用了 TCP 协议，数据一定不会丢吗？</a></p></blockquote><p>大家后，我是小林。</p><p>问大家一句：TCP 是一个可靠的传输协议，那它一定能保证数据不丢失吗？</p><p>这次，就跟大家探讨这个问题。</p><h2 id="数据包的发送流程" tabindex="-1">数据包的发送流程 <a class="header-anchor" href="#数据包的发送流程" aria-label="Permalink to &quot;数据包的发送流程&quot;">​</a></h2><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1d0a1d60ca4f720423911cf8f25c4ac3.png" alt="聊天软件三端通信"></p><p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP协议</strong>进行通信。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7e8bae365b8d27560aac1cd28f501156.png" alt="聊天软件两端通信"></p><p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立TCP连接。</p><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过n多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/28e4d6b004530fbf75fe346d181baa81.png" alt="网络发包收包全景图"></p><blockquote><p>画了那么大一张图，只水了200字做解释，我多少是有些心痛的。</p></blockquote><p>到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p><p>可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p><p>整条链路下来，有不少地方可能会发生丢包。</p><p>但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p><h2 id="建立连接时丢包" tabindex="-1">建立连接时丢包 <a class="header-anchor" href="#建立连接时丢包" aria-label="Permalink to &quot;建立连接时丢包&quot;">​</a></h2><p>TCP协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/923f5005edb536c0d07b096bbf2ca282.png" alt="TCP三次握手"></p><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/02a78bb83fe167324f26e8c910d7a7a2.png" alt="半连接队列和全连接队列"></p><p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p>可以通过下面的方式查看是否存在这种丢包行为。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 全连接队列溢出次数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># netstat -s | grep overflowed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    4343</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> times</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> listen</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> queue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> of</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> socket</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> overflowed</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 半连接队列溢出次数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    109</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> times</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> listen</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> queue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> of</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> socket</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> overflowed</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从现象来看就是连接建立失败。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/591d630098b4fc5316a5005f1e94b844.png" alt="图片"></p><h2 id="流量控制丢包" tabindex="-1">流量控制丢包 <a class="header-anchor" href="#流量控制丢包" aria-label="Permalink to &quot;流量控制丢包&quot;">​</a></h2><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p><p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f2821018be08a2f27561155e8085de4.png" alt="qdisc丢包"></p><p>可以通过下面的<code>ifconfig</code>命令，查看TX下的dropped字段，当它大于0时，则<strong>有可能</strong>是发生了流控丢包。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ifconfig eth0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eth0:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> flags=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4163</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">UP,BROADCAST,RUNNING,MULTICAS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  mtu</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1500</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        inet</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 172.21</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.66.69</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  netmask</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 255.255</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.240.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  broadcast</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 172.21</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.79.255</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        inet6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fe80::216:3eff:fe25:269f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  prefixlen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  scopeid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x20</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">lin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        ether</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 00</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:16:3e:25:26:9f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  txqueuelen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (Ethernet)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> packets</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6962682</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bytes</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1119047079</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (1.0 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">GiB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> errors</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  dropped</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  overruns</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  frame</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        TX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> packets</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9688919</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  bytes</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2072511384</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (1.9 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">GiB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        TX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> errors</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  dropped</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> overruns</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  carrier</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  collisions</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将eth0网卡的流控队列长度从1000提升为1500.</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ifconfig eth0 txqueuelen 1500</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="网卡丢包" tabindex="-1">网卡丢包 <a class="header-anchor" href="#网卡丢包" aria-label="Permalink to &quot;网卡丢包&quot;">​</a></h2><p>网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p><h3 id="ringbuffer过小导致丢包" tabindex="-1">RingBuffer过小导致丢包 <a class="header-anchor" href="#ringbuffer过小导致丢包" aria-label="Permalink to &quot;RingBuffer过小导致丢包&quot;">​</a></h3><p>上面提到，在接收数据时，会将数据暂存到<code>RingBuffer</code>接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f3ed2d6c4e2e154849f1e661528fe89.png" alt="RingBuffer满了导致丢包"></p><p>我们可以通过下面的命令去查看是否发生过这样的事情。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ifconfig</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eth0:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> errors</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  dropped</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  overruns</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  frame</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>查看上面的<code>overruns</code>指标，它记录了由于<code>RingBuffer</code>长度不足导致的溢出次数。</p><p>当然，用<code>ethtool</code>命令也能查看。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ethtool -S eth0|grep rx_queue_0_drops</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但这里需要注意的是，因为一个网卡里是可以有<strong>多个RingBuffer</strong>的，所以上面的<code>rx_queue_0_drops</code>里的0代表的是<strong>第0个RingBuffer</strong>的丢包数，对于多队列的网卡，这个0还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p><p>当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#ethtool -g eth0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Ring</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> parameters</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pre-set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> maximums:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        4096</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Mini:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Jumbo:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TX:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        4096</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Current</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hardware</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> settings:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        1024</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Mini:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Jumbo:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TX:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        1024</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的输出内容，含义是<strong>RingBuffer最大支持4096的长度，但现在实际只用了1024。</strong></p><p>想要修改这个长度可以执行<code>ethtool -G eth1 rx 4096 tx 4096</code>将发送和接收RingBuffer的长度都改为4096。</p><p><strong>RingBuffer</strong>增大之后，可以减少因为容量小而导致的丢包情况。</p><h3 id="网卡性能不足" tabindex="-1">网卡性能不足 <a class="header-anchor" href="#网卡性能不足" aria-label="Permalink to &quot;网卡性能不足&quot;">​</a></h3><p>网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p><p>我们可以通过<code>ethtool</code>加网卡名，获得当前网卡支持的最大速度。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ethtool eth0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Settings</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Speed:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Mb/s</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到，我这边用的网卡能支持的最大传输速度<strong>speed=1000Mb/s</strong>。</p><p>也就是俗称的千兆网卡，但注意这里的单位是<strong>Mb</strong>，这里的<strong>b是指bit，而不是Byte。1Byte=8bit</strong>。所以10000Mb/s还要除以8，也就是理论上网卡最大传输速度是<code>1000/8 = 125MB/s</code>。</p><p>我们可以通过<code>sar命令</code>从网络接口层面来分析数据包的收发情况。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># sar -n DEV 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Linux</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.0-1127.19.1.el7.x86_64</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      2022</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">年07月27日</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     _x86_64_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (1 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">08时35分39秒</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     IFACE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   rxpck/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   txpck/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    rxkB/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    txkB/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    rxcmp/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   txcmp/s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  rxmcst/s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">08时35分40秒</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      eth0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      6.06</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      4.04</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0.35</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    121682.33</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   0.00</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0.00</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0.00</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其中 <strong>txkB/s是指当前每秒发送的字节（byte）总数，rxkB/s是指每秒接收的字节（byte）总数</strong>。</p><p>当两者加起来的值约等于<code>12~13w字节</code>的时候，也就对应大概<code>125MB/s</code>的传输速度。此时达到网卡性能极限，就会开始丢包。</p><p>遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p><h2 id="接收缓冲区丢包" tabindex="-1">接收缓冲区丢包 <a class="header-anchor" href="#接收缓冲区丢包" aria-label="Permalink to &quot;接收缓冲区丢包&quot;">​</a></h2><p>我们一般使用<code>TCP socket</code>进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p><p>当我们想要发一个数据包，会在代码里执行<code>send(msg)</code>，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9cd22437777205662048c73cc5855add.png" alt="tcp_sendmsg逻辑"></p><p>而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p><p>这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看接收缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># sysctl net.ipv4.tcp_rmem</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">net.ipv4.tcp_rmem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4096</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    87380</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   6291456</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看发送缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># sysctl net.ipv4.tcp_wmem</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">net.ipv4.tcp_wmem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4096</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    16384</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   4194304</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在min和max之间动态调整。</strong></p><p><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p><p>对于<strong>发送缓冲区</strong>，执行send的时候，如果是<strong>阻塞</strong>调用，那就会等，等到缓冲区有空位可以发数据。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7312e536393463dcf0d57aeb07f28ed5.gif" alt="send阻塞"></p><p>如果是<strong>非阻塞</strong>调用，就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是 <code>Try again</code>。让应用程序下次再重试。这种情况下一般不会发生丢包。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f378a299ca60c490ee5437e1143916c8.gif" alt="send非阻塞"></p><p>当接受缓冲区满了，事情就不一样了，它的TCP接收窗口会变为0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的<code>win=0</code>，告诉发送端，&quot;球球了，顶不住了，别发了&quot;。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2df66c2e1d9f1245813e8d1de7482e0c.png" alt="recv_buffer丢包"></p><p>我们可以通过下面的命令里的<code>TCPRcvQDrop</code>查看到有没有发生过这种丢包现象。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/net/netstat</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TcpExt:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SyncookiesSent</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> TCPRcvQDrop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SyncookiesFailed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TcpExt:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">              157</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">              60116</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但是说个伤心的事情，我们一般也看不到这个<code>TCPRcvQDrop</code>，因为这个是<code>5.9版本</code>里引入的打点，而我们的服务器用的一般是<code>2.x~3.x</code>左右版本。你可以通过下面的命令查看下你用的是什么版本的linux内核。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># cat /proc/version</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Linux</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> version</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.0-1127.19.1.el7.x86_64</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="两端之间的网络丢包" tabindex="-1">两端之间的网络丢包 <a class="header-anchor" href="#两端之间的网络丢包" aria-label="Permalink to &quot;两端之间的网络丢包&quot;">​</a></h2><p>前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p>这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p><h3 id="ping命令查看丢包" tabindex="-1"><strong>ping命令查看丢包</strong> <a class="header-anchor" href="#ping命令查看丢包" aria-label="Permalink to &quot;**ping命令查看丢包**&quot;">​</a></h3><p>比如我们知道目的地的域名是 <code>baidu.com</code>。想知道你的机器到baidu服务器之间，有没有产生丢包行为。可以使用ping命令。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/56bdca9995c0c2a343b2b73b67933b78.png" alt="ping查看丢包"></p><p>倒数第二行里有个<code>100% packet loss</code>，意思是丢包率100%。</p><p>但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p><p><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p><p>有。</p><h3 id="mtr命令" tabindex="-1"><strong>mtr命令</strong> <a class="header-anchor" href="#mtr命令" aria-label="Permalink to &quot;**mtr命令**&quot;">​</a></h3><p>mtr命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p>像下面这样执行命令。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4a2d8dbfb648bcced864fb653af9f036.png" alt="mtr_icmp"></p><p>其中 -r 是指report，以报告的形式打印结果。</p><p>可以看到<code>Host</code>那一列，出现的都是链路中间每一跳的机器，<code>Loss</code>的那一列就是指这一跳对应的丢包率。</p><p>需要注意的是，中间有一些是host是<code>???</code>，那个是因为<strong>mtr默认用的是ICMP包</strong>，有些节点限制了<strong>ICMP包</strong>，导致不能正常展示。</p><p>我们可以在mtr命令里加个<code>-u</code>，也就是使用<strong>udp包</strong>，就能看到部分???对应的IP。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0650adc524ab7d82028dc83cfc9961e1.png" alt="mtr-udp"></p><p>把<strong>ICMP包和UDP包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p><p>还有个小细节，<code>Loss</code>那一列，我们在icmp的场景下，关注<strong>最后一行</strong>，如果是0%，那不管前面loss是100%还是80%都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p><p>但如果<strong>最后一行是20%，再往前几行都是20%左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7142a4e285024dc6aadea4255984c485.png" alt="图片"></p><h2 id="发生丢包了怎么办" tabindex="-1">发生丢包了怎么办 <a class="header-anchor" href="#发生丢包了怎么办" aria-label="Permalink to &quot;发生丢包了怎么办&quot;">​</a></h2><p>说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p><p>但问题来了，发生丢包了怎么办？</p><p>这个好办，用<strong>TCP协议</strong>去做传输。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b2225e071fec7cfb240aa295ed4037bf.png" alt="TCP是什么"></p><p>建立了TCP连接的两端，发送端在发出数据后会等待接收端回复<code>ack包</code>，<code>ack包</code>的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用TCP不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c1460d52efe7c5e4d80c2f7160d5b126.png" alt="图片"></p><p>这时候问题又来了。</p><p>假设<strong>某绿皮聊天软件用的就是TCP协议。</strong></p><p>在聊天的时候， 发生丢包了，丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p><p>于是乎，问题就变成了，<strong>用了 TCP 协议，就一定不会丢包吗？</strong></p><h2 id="用了tcp协议就一定不会丢包吗" tabindex="-1">用了TCP协议就一定不会丢包吗 <a class="header-anchor" href="#用了tcp协议就一定不会丢包吗" aria-label="Permalink to &quot;用了TCP协议就一定不会丢包吗&quot;">​</a></h2><p>我们知道TCP位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的HTTP或者各类RPC协议。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c6794dd51c8780f12e4022fc964ebb0a.png" alt="四层网络协议"></p><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层TCP协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层TCP接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里TCP的任务就结束了。</p><p>TCP任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9286ab84bcaa74576bc11c8e9322fee9.png" alt="使用TCP协议却发生丢包"></p><p><strong>虽然概率很小，但它就是发生了</strong>。</p><p>合情合理，逻辑自洽。</p><h2 id="这类丢包问题怎么解决" tabindex="-1">这类丢包问题怎么解决？ <a class="header-anchor" href="#这类丢包问题怎么解决" aria-label="Permalink to &quot;这类丢包问题怎么解决？&quot;">​</a></h2><p>故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p><p><strong>其实前面说的都对，没有一句是假话</strong>。</p><p>但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p><p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p><strong>现在我们重新将服务器加回来。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d53659df39d64db4780d2816bd8314d1.png" alt="聊天软件三端通信"></p><p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>可以看出，<strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul><p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说丢包不可避免。</li><li>平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。</li><li>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。</li><li>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</li></ul><hr><p><em><strong>哈喽，我是小林，就爱图解计算机基础，如果觉得文章对你有帮助，欢迎微信搜索「小林coding」</strong></em></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E5%85%B6%E4%BB%96/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BB%8B%E7%BB%8D.png" alt="img"></p>`,154),e=[t];function l(r,h,k,g,o,d){return n(),i("div",null,e)}const C=s(p,[["render",l]]);export{F as __pageData,C as default};
